= Фрагменты
:page-aliases: screens/screen-fragment-events.adoc

Фрагмент - это структурный элемент пользовательского интерфейса, который можно использовать в качестве компонента экранов или других фрагментов. Фрагмент является композитным компонентом и обладает следующими дополнительными возможностями:

* Содержимое фрагмента можно определять в формате XML.
* Элемент XML `fragment` позволяет декларативно включать фрагменты в экраны и другие фрагменты.
* Класс фрагмента (называемый также контроллер) поддерживает инжекцию бинов Spring и UI-компонентов фрагмента, а также аннотированные методы в качестве обработчиков.
* Когда фрагмент полностью инициализирован, отправляется событие `ReadyEvent`.
* В XML фрагмента можно определить xref:flow-ui:actions.adoc[действия] и xref:flow-ui:data-components.adoc[компоненты данных] (контейнеры и загрузчики). Компоненты данных можно пометить как `provided` для их получения из экрана-владельца.
* Студия предлагает шаблон xref:studio:view-wizard.adoc#creating-blank-fragment[Blank fragment] для генерации фрагментов, отображает их в окне инструментов Jmix и позволяет использовать xref:studio:view-designer.adoc[визуальный дизайнер] так же, как для экранов.

Фрагменты в настоящее время не поддерживают xref:flow-ui:facets.adoc[фасеты].

TIP: Fragments can be used to render items within certain UI components, such as xref:vc/components/virtualList.adoc[virtualList], or xref:vc/components/dataGrid.adoc[dataGrid] columns. This is achieved using a nested xref:flow-ui:vc/miscellaneous/renderers.adoc#fragment-renderer[fragmentRenderer] element. The `fragmentRenderer` element specifies a Java class that extends `io.jmix.flowui.fragmentrenderer.FragmentRenderer`. This class is responsible for taking a data item and rendering it within the fragment's template.

[[fragment-content]]
== Содержимое фрагмента

Аннотация `@FragmentDescriptor` определяет строковое значение, которое представляет собой путь к файлу XML, используемому для инициализации фрагмента. Если значение содержит только имя файла (и не начинается с `/`), то предполагается, что файл находится в пакете класса фрагмента.

Элементы, доступные в XML-дескрипторе:

* `content` - обязательный элемент, содержащий макета фрагмент (аналогично элементу `layout` экрана). Поскольку корневым компонентом фрагмента может быть любой компонент, у `content` нет атрибутов и он не представляет какой-либо UI-компонент.

* `actions` - необязательный элемент действий фрагмента (аналогичный элементу `actions` экрана). Если для действия задано сочетание клавиш, оно привязывается к корневому компоненту фрагмента. Другими словами, сочетание клавиш может быть активировано только в том случае, если фокус находится внутри фрагмента.

* `data` — необязательный элемент данных фрагмента (аналогичный элементу `data` экрана). Фрагмент может определить свои собственные контейнеры данных и загрузчики, или получить их по идентификатору из включающего экрана или фрагмента, как описано в разделе xref:flow-ui:fragments/using-fragments.adoc#using-data-components[Использование компонентов данных].

Пример XML-дескриптора фрагмента:

[source,xml,indent=0]
.customer-list-fragment.xml
----
include::example$/onboarding/src/main/resources/com/company/onboarding/view/customer/customer-list-fragment.xml[tags=fragment-xml]
----

[[fragment-api]]
== API фрагментов

* `getFragmentData()` - возвращает объект `FragmentData`, определяющий методы взаимодействия с компонентами данных фрагмента.

* `getFragmentActions()` - возвращает объект `FragmentActions`, определяющий методы взаимодействия с действиями фрагмента.

* `getParentController()` - возвращает родительский объект `FragmentOwner`. Это может быть `View` или `Fragment`.

* `findInnerComponent()` / `getInnerComponent()` - возвращают внутренний компонент с указанным идентификатором. Эти методы ищут только среди компонентов, добавленных через XML-дескриптор.

[[fragment-events]]
== События фрагментов

* `ReadyEvent` - событие, которое посылается после создания фрагмента и всех его декларативно определенных внутренних компонентов, и полной их инициализации. В обработчике этого события можно выполнить окончательную настройку фрагмента и его внутренних компонентов. Например:
+
.CustomerListFragment.java
[source,java,indent=0]
----
include::example$/onboarding/src/main/java/com/company/onboarding/view/customer/CustomerListFragment.java[tags=fragment-java]
----
<1> Вызывает метод `load()` всех загрузчиков фрагмента, включая xref:fragments/using-fragments.adoc#provided-data-components[предоставленные].


[[fragment-autowiring]]
== Автоматическое связывание

Аналогично экранам, фрагменты поддерживают инжекцию компонентов, определенных в XML, и вызов аннотированных методов обработчика:

[source,java,indent=0]
----
include::example$/onboarding/src/main/java/com/company/onboarding/view/customer/CustomerListFragment2.java[tags=autowire]
----
<1> Инжектирует UI-компонент.
<2> Инжектирует контейнер данных.
<3> Подписывается на событие `ReadyEvent` фрагмента.
<4> Подписывается на событие `ClickEvent` кнопки.
<5> Устанавливает делегат загрузки.
<6> Предоставляет `Renderer` для таблицы данных.

В дополнение к этому, можно подписаться на события включающего экрана, определив `target = Target.HOST_CONTROLLER` в аннотации `@Subscribe`:

[source,java,indent=0]
----
include::example$/onboarding/src/main/java/com/company/onboarding/view/customer/CustomerListFragment2.java[tags=host]
----