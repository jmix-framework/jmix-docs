= DataGrid

++++
<div class="backoffice-ui-live-demo-container">
    <a href="https://demo.jmix.io/sampler/#main/sample?id=datagrid-basic-settings" class="live-demo-btn" target="_blank">ДЕМОНСТРАЦИЯ</a>
</div>
++++

`DataGrid`, подобно компоненту xref:vcl/components/table.adoc[Table], позволяет выводить информацию в виде таблицы, сортировать ее, вызывать действия для выбранных строк, а также более эффективно управлять строками и колонками таблицы за счет ленивой загрузки данных при прокрутке.

В дополнение к этому, `DataGrid` обладает следующими функциями:

* <<editing,Внутристроковой редактор>>;
* <<item-details-generator,Генератор Item Details>>;
* Расширенная настройка <<headers-footers,заголовков и строк итогов>>;
* <<column-freezing,Фиксация колонок>>.

Однако у `DataGrid` нет соответствующей реализации с возможностями группировки (у `Table` xref:vcl/components/group-table.adoc[есть]).

XML-имя компонента: `dataGrid`.

[[basics]]
== Основы

Ниже представлен типичный `dataGrid`:

image::vcl/components/data-grid-anatomy.png[align="center"]

. Панель кнопок
. Кнопка сортировки
. Разбивка на страницы
. Кнопка управления колонкой
. Строки
. Строка заголовка

Ниже представлен пример объявления `dataGrid` в XML-дескрипторе экрана:

[source, xml,indent=0]
----
include::example$/ex1/src/main/resources/ui/ex1/screen/component/datagrid/data-grid-screen.xml[tags=data-start;collection-customers;data-end;layout-start;data-grid-simple;layout-end;]
----

В приведенном примере есть xref:data/collection-container.adoc[контейнер коллекции] для сущности `Customer`. Компонент `DataGrid` привязан к контейнеру с помощью атрибута `dataContainer`, в то время как его элемент `columns` определяет, какие атрибуты сущности отображаются в колонках таблицы.

[[data-binding]]
== Привязка данных

[[declarative-binding]]
=== Декларативная привязка

Обычно `dataGrid` привязывается к данным декларативно в XML-дескрипторе экрана, используя атрибут `dataContainer`. Он должен ссылаться на xref:data/collection-container.adoc[контейнер коллекции].

[[using-key-value-containers]]
=== Использование контейнеров Key-Value

Таблицу можно привязать к xref:data/key-value-containers.adoc[контейнеру key-value] для отображения результатов запроса, который возвращает скалярные значения и/или агрегаты. Например:

[source, xml,indent=0]
----
include::example$/ex1/src/main/resources/ui/ex1/screen/component/datagrid/data-grid-screen.xml[tags=data-start;key-value-collection-sales;data-end;layout-start;key-value-grid;layout-end;]
----

[[meta-class]]
=== Программная привязка

Если необходимо определить контейнер данных программно в контроллере экрана, установите атрибут xref:vcl/xml.adoc#meta-class[metaClass] вместо xref:vcl/xml.adoc#data-container[dataContainer] в XML-дескрипторе:

[source, xml,indent=0]
----
include::example$/ex1/src/main/resources/ui/ex1/screen/component/datagrid/data-grid-screen.xml[tags=meta-class-data-grid]
----

В контроллере экрана используйте класс `ContainerDataGridItems` для привязки таблицы к контейнеру данных:

[source,java,indent=0]
----
include::example$/ex1/src/main/java/ui/ex1/screen/component/datagrid/DataGridScreen.java[tags=inject-customersDataGrid;inject-customersDc;init-start;programmatic-binding;init-end]
----

[[columns]]
== Columns

Набор колонок `DataGrid` определяется элементом `columns`. Если он не задан, то колонки таблицы будут автоматически взяты из xref:data-access:fetching.adoc#fetch-plan[фетч-плана], определенного в `dataContainer`.

Элемент `columns` имеет следующие атрибуты:

[[include-all]]
* `includeAll` включает все атрибуты из `fetchPlan`, определенного в `dataContainer`.
+
В приведенном ниже примере мы покажем все атрибуты из фетч-плана, используемого в `customersDc`:
+
[source, xml,indent=0]
----
include::example$/ex1/src/main/resources/ui/ex1/screen/component/datagrid/data-grid-screen.xml[tags=columns-include-all]
----
+
Если фетч-план сущности содержит ссылочный атрибут, этот атрибут выводится в соответствии с его xref:data-model:entities.adoc#instance-name[именем экземпляра]. Если нужно показать конкретный вложенный атрибут, он должен быть определен в фетч-плане, а также в элементе `column`:
+
[source, xml,indent=0]
----
include::example$/ex1/src/main/resources/ui/ex1/screen/component/datagrid/data-grid-screen.xml[tags=data-start;collection-customers-with-country;data-end;layout-start;columns-include-all-reference;layout-end]
----

[[exclude]]
* `exclude` содержит разделенный запятыми список атрибутов, которые не должны быть показаны в `DataGrid`.
+
В приведенном ниже примере мы покажем все атрибуты за исключением `id`, `maritalStatus`, и `email`:
+
[source, xml,indent=0]
----
include::example$/ex1/src/main/resources/ui/ex1/screen/component/datagrid/data-grid-screen.xml[tags=columns-exclude]
----

[[column]]
=== Column

Каждая колонка описывается во вложенном элементе `column`.

[[column-id]]

`id` - необязательный атрибут, содержит строковый идентификатор колонки. Если не задан, в качестве идентификатора колонки будет использоваться строковое значение атрибута `property`. Если не указан ни атрибут `id`, ни атрибут `property`, во время выполнения будет брошено исключение `GuiDevelopmentException`. Атрибут `id` является обязательным для <<data-grid-column-generation,генерируемых колонок>>.

[[column-property]]

`property` содержит название атрибута сущности, выводимого в колонке. Может быть как непосредственным атрибутом сущности, находящейся в контейнере данных, так и атрибутом связанной сущности; переход по графу объектов обозначается точкой. Например:

[source, xml,indent=0]
----
include::example$/ex1/src/main/resources/ui/ex1/screen/component/datagrid/data-grid-screen.xml[tags=grid-column]
----

[[column-caption-options]]
=== Заголовок колонки

[[column-caption]]
`caption` - необязательный атрибут, содержит заголовок колонки. Если не задан, будет отображено xref:localization:message-bundles.adoc#localizing-data-model[локализованное название] атрибута сущности.

Этот заголовок также используется для названия колонки в выпадающем меню управления колонками, если оно не определено в атрибуте <<collapsing-toggle-caption,collapsingToggleCaption>>.

[[column-collapsing]]
=== Сворачивание колонок

[[column-collapsed]]
`collapsed` - необязательный атрибут, при указании `true` колонка будет изначально скрыта. Пользователи могут управлять видимостью колонки с помощью меню, доступного по нажатию кнопки image:vcl/components/table-column-control-button.png[] в правом верхнем углу таблицы, если атрибут <<column-collapsing-allowed,columnsCollapsingAllowed>> имеет значение `true`. По умолчанию имеет значение `false`.
[[column-collapsible]]
Атрибут `collapsible` определяет, может ли пользователь управлять отображением колонок с помощью кнопки управления колонкой. По умолчанию имеет значение `true`.

[[collapsing-toggle-caption]]

Атрибут `collapsingToggleCaption` задает имя колонки в меню управления колонкой. По умолчанию имеет значение `null`, и в этом случае берется значение заголовка колонки, доступного из свойства <<column-caption,caption>>.

[source, xml,indent=0]
----
include::example$/ex1/src/main/resources/ui/ex1/screen/component/datagrid/data-grid-screen.xml[tags=grid-collapsed]
----

image::vcl/components/data-grid-collapse.gif[align="center"]

Как можно видеть, колонка `age` по умолчанию свернута, но пользователи могут развернуть ее из выпадающего меню кнопки image:vcl/components/table-column-control-button.png[].

В то же время колонки `firstName` и `lastName` не могут быть свернуты пользователем.

Настраиваемый заголовок для колонки `hobby` отображается в выпадающем меню кнопки управления колонкой.

Сворачивание колонки можно отследить с помощью <<column-collapsing-change-event,ColumnCollapsingChangeEvent>>.

[[column-width]]
=== Ширина колонки

`width` - необязательный атрибут, отвечает за изначальную ширину колонки. Может принимать только числовые значения в пикселах.

[source, xml,indent=0]
----
include::example$/ex1/src/main/resources/ui/ex1/screen/component/datagrid/data-grid-screen.xml[tags=grid-width]
----

image::vcl/components/data-grid-column-width.png[align="center"]

[[column-expand-ratio]]
`expandRatio` - необязательный атрибут, устанавливает соотношение, с которым колонка расширяется. Если хотя бы одной колонке установлено иное значение, все неявные значения игнорируются и учитываются только явно присвоенные.

По умолчанию все колонки расширяются равномерно (словно все колонки имеют `expandRatio = 1`).

Если одновременно задать атрибуты `width` и `expandRatio`, атрибут `expandRatio` будет проигнорирован.

[source, xml,indent=0]
----
include::example$/ex1/src/main/resources/ui/ex1/screen/component/datagrid/data-grid-screen.xml[tags=grid-expandRatio-column]
----

image::vcl/components/data-grid-ratio.png[align="center"]

В приведенном выше примере компонент `DataGrid` имеет три колонки с соотношениями расширения (expand ratio) `0`, `1`, и `2` соответственно. Колонка с соотношением `0` будет иметь ровно такую ширину, какая требуется для ее содержимого. Колонка с соотношением `1` будет широкой настолько, насколько требуется, плюс треть любого лишнего места, потому что всего есть три части, и эта колонка занимает одну из них. Колонка с соотношением `2` будет широкой настолько, насколько требуется, плюс две трети лишнего места.

Чтобы очистить значение расширения, задайте отрицательное число для атрибута `expandRatio`.

[[column-minimum-width]]
Атрибут `minimumWidth` отвечает за минимальную ширину колонки в пикселях при расширении.

Значение минимальной ширины колонки по умолчанию указано в свойстве xref:app-properties.adoc#jmix.ui.data-grid.default-column-min-width[jmix.ui.data-grid.default-column-min-width].

[[column-maximum-width]]

Атрибут `maximumWidth` отвечает за максимальную ширину колонки в пикселях при расширении.

Значение максимальной ширины колонки по умолчанию указано в свойстве xref:app-properties.adoc#jmix.ui.data-grid.default-column-max-width[jmix.ui.data-grid.default-column-max-width].

[[column-resizable]]
=== Изменение размера колонок

Пользователи могут изменять размер колонок `DataGrid`:

image::vcl/components/data-grid-resize.gif[align="center"]

Атрибут `resizable` определяет, может ли пользователь изменять размер колонки. По умолчанию можно изменять размер всех колонок.

[[column-resize-mode]]
Используйте атрибут `columnResizeMode`, чтобы определить режим изменения размера. Поддерживаются два режима:

* В режиме `ANIMATED` размер колонки меняется сразу вслед за курсором.
* В режиме `SIMPLE` размер колонки меняется только после того, как курсор будет отпущен.

Изменение размера колонок можно отслеживать с помощью <<column-resize-event,ColumnResizeEvent>>.

[[reordering-allowed]]
=== Изменение порядка колонок

`DataGrid` позволяет пользователям менять порядок колонок с помощью перетаскивания.

// TODO: поменять тут скриншот. Этот от компонента Table. Жду решения тикета https://github.com/Haulmont/jmix-ui/issues/623

image::vcl/components/table-columns-reordering.gif[align="center"]

Возможность менять порядок колонок включена по умолчанию. Чтобы отключить ее, задайте для атрибута `reorderingAllowed` значение `false`.

Изменение расположения колонок можно отслеживать с помощью <<column-reorder-event,ColumnReorderEvent>>.

[[column-freezing]]
=== Фиксация колонок

`DataGrid` позволяет фиксировать колонки на своей левой стороне. Фиксацию можно использовать, чтобы основные колонки оставались всегда видимыми в таблице с большим количеством колонок. Фиксированные колонки не прокручиваются при горизонтальной прокрутке таблицы.

Атрибут `frozenColumnCount` устанавливает количество фиксированных колонок. Значение `0` означает, что фиксированных колонок не будет, кроме встроенной колонки с чекбоксами для <<checkbox-selection,множественного выбора>>, если она используется. Значение `-1` означает, что фиксированных колонок не будет вообще. По умолчанию имеет значение `0`.

Рассмотрим пример `DataGrid`, в котором первые две колонки зафиксированы.

[source, xml,indent=0]
----
include::example$/ex1/src/main/resources/ui/ex1/screen/component/datagrid/data-grid-screen.xml[tags=grid-frozen-column]
----

image::vcl/components/data-grid-frozen.gif[align="center"]

== Размеры

=== Размеры таблицы

В дополнение к атрибутам xref:vcl/xml.adoc#height[height] и xref:vcl/xml.adoc#width[width], `DataGrid` имеет необязательные атрибуты `minHeight` и `minWidth`:

[[min-height]]
* `minHeight` определяет минимальную высоту компонента `DataGrid`.

[[min-width]]
* `minWidth` определяет минимальную ширину компонента `DataGrid`.

=== Размеры колонок

См. атрибуты `width`, `expandRatio`, `minimumWidth` и `maximumWidth` в разделе <<column-width>>.

=== Размеры строк

Чтобы задать высоту строки заголовка, используйте атрибут <<header-row-height,headerRowHeight>>.

[[body-row-height]]
Используйте атрибут `bodyRowHeight`, чтобы задать высоту строки тела таблицы в пикселях. Значение `-1` означает, что высота строки рассчитывается на основе темы для пустой строки перед отображением `DataGrid`.

Чтобы задать высоту строки итогов, используйте атрибут <<footer-row-height,footerRowHeight>>.

В приведенном ниже примере показан компонент `DataGrid` с настроенной высотой строк заголовка и основных строк:

[source, xml,indent=0]
----
include::example$/ex1/src/main/resources/ui/ex1/screen/component/datagrid/data-grid-screen.xml[tags=sized-grid]
----

image::vcl/components/data-grid-custom-row-height.png[align="center"]

[[selection]]
== Выделение

Компонент `DataGrid` позволяет пользователям выделять одну или несколько строк.

[[selection-mode]]
Атрибут `selectionMode` определяет режим выделения строк. Существует 4 предопределенных режима:

* `SINGLE`;
* `MULTI`;
* `MULTI_CHECK`;
* `NONE`.

Выделение строк можно отслеживать с помощью <<selection-event,SelectionEvent>>.

[[single-selection]]
=== Единичный выбор строки

Если у атрибута `selectionMode` задано значение `SINGLE`, то пользователи смогут выделять одну строку за раз. Единичный выбор строки установлен по умолчанию.

[[multi-selection]]
=== Множественный выбор

Если у атрибута `selectionMode` задано значение `MULTI`, то пользователи смогут выделять несколько строк за раз, используя клавиатуру или мышь и зажимая клавиши *Ctrl* или *Shift*.

[[checkbox-selection]]
=== Множественный выбор с чекбоксами

Если у атрибута `selectionMode` задано значение `MULTI_CHECK`, то пользователи смогут выделять несколько строк, используя колонку чекбоксов слева.

image::vcl/components/data-grid-checkbox-select.png[align="center"]

[[none-selection]]
=== Отключение выделения

Если атрибут `selectionMode` имеет значение `NONE`, выделение строк отключено.

[[text-selection-enabled]]
=== Выделение текста

Атрибут `textSelectionEnabled` разрешает или запрещает выделение текста в ячейках `DataGrid`. По умолчанию имеет значение `false`.

== Заполнитель

`DataGrid` позволяет задать позволяет настроить заполнитель в виде сообщения и/или ссылки, отображаемый в случае, если контейнер данных пуст или не задан.

[[empty-state-message]]
Заполнитель-сообщение определяется атрибутом `emptyStateMessage`. Он должен содержать информацию о том, почему таблица пуста.

[[empty-state-link-message]]
Заполнитель-ссылка определяется атрибутом `emptyStateLinkMessage`. В нем должно быть описано действие, которое необходимо выполнить для заполнения таблицы.

Например:

[source, xml,indent=0]
----
include::example$/ex1/src/main/resources/ui/ex1/screen/component/datagrid/data-grid-screen.xml[tags=placeholder-grid]
----

image::vcl/components/data-grid-placeholder.png[align="center"]

И `emptyStateMessage`, и `emptyStateLinkMessage` могут загружать сообщения из xref:localization:message-bundles.adoc#using-messages-in-ui[пакета сообщений].

Нажатия по ссылке можно отслеживать с помощью <<empty-state-link-click-handler,EmptyStateLinkClickHandler>>.

[[column-collapsing-allowed]]
== Управление видимостью колонок

Пользователи могут выбрать, какие колонки будут <<column-collapsing,свернуты>>, используя кнопку управления колонками image:vcl/components/table-column-control-button.png[] в правой части заголовка таблицы.

Отображаемые в данный момент колонки отмечены в выпадающем меню. В нем есть дополнительные пункты:

* `Select all` - показать все колонки;
* `Deselect all` - спрятать все возможные колонки.

image::vcl/components/data-grid-column-collapsing-allowed.png[align="center"]

Если `columnsCollapsingAllowed` имеет значение `false`, пользователи не смогут сворачивать колонки. Значение по умолчанию – `true`.

[[headers-footers]]
== Заголовки и строки итогов

[[header-visible]]
Атрибут `headerVisible` определяет видимость заголовка `DataGrid`. По умолчанию имеет значение `true`.

[[header-row-height]]
Используйте атрибут `headerRowHeight`, чтобы задать высоту строки заголовка в пикселях. Значение `-1` означает, что высота строки рассчитывается на основе темы для пустой строки перед отображением `DataGrid`. Значение по умолчанию – `-1`.

[[footer-visible]]
Атрибут `footerVisible` определяет видимость строки итогов `DataGrid`. По умолчанию имеет значение `true`.

[[footer-row-height]]
Используйте атрибут `footerRowHeight` чтобы задать высоту строки итогов в пикселях. Значение `-1` означает, что высота строки рассчитывается на основе темы для пустой строки перед отображением `DataGrid`. Значение по умолчанию – `-1`.

Интерфейсы `HeaderRow` и `FooterRow` используются для отображения ячеек заголовка и итогов соответственно. Эти ячейки могут быть объединены для нескольких колонок.

Для создания и настройки заголовков и итогов используются следующие методы:

* `appendHeaderRow()`, `appendFooterRow()` - добавляет новую строку внизу секции заголовков/итогов.
* `prependHeaderRow()`, `prependFooterRow()` - добавляет новую строку наверху секции заголовков/итогов.
* `addHeaderRowAt()`, `addFooterRowAt()` - вставляет новую строку на заданную позицию в секции. Текущая строка на этой позиции, а также все следующие ниже, сдвигаются вниз с увеличением их индекса на 1.
* `removeHeaderRow()`, `removeFooterRow()` - удаляет указанную строку в секции.
* `getHeaderRowCount()`, `getFooterRowCount()` - возвращает количество строк в секции.
* `setDefaultHeaderRow()` - устанавливает заголовок таблицы по умолчанию. Интерфейс стандартного заголовка по умолчанию включает в себя элементы для сортировки колонок таблицы.

Интерфейсы `HeaderCell` и `FooterCell` позволяют управлять статическими ячейками:

* `setStyleName()` - устанавливает пользовательский стиль для данной ячейки.
* `getCellType()` - возвращает тип содержимого данной ячейки. Перечисление `DataGridStaticCellType` содержит 3 стандартных типа статических ячеек:

** `TEXT`
** `HTML`
** `COMPONENT`

* `getComponent()`, `getHtml()`, `getText()` - возвращает содержимое данной ячейки в зависимости от ее типа.

Ниже приведен пример таблицы `DataGrid` с заголовком, содержащим объединtнные ячейки, и строкой итогов, в которой отображаются вычисляемые значения:

[source, xml,indent=0]
----
include::example$/ex1/src/main/resources/ui/ex1/screen/component/datagrid/data-grid-screen.xml[tags=grid-header-footer]
----

[source,java,indent=0]
----
include::example$/ex1/src/main/java/ui/ex1/screen/component/datagrid/DataGridScreen.java[tags=init-footer-header-var;init-start;init-footer-header;init-end;init-footer;init-header;get-average;calculate-member-count]
----

image::vcl/components/data-grid-header-footer.png[align="center"]

[[aggregatable]]
== Агрегация

`DataGrid` поддерживает агрегацию значений в строки.

Поддерживаются следующие операции:

* `SUM` - вычисление суммы;
* `AVG` - вычисление среднего значения;
* `COUNT` - вычисление общего количества;
* `MIN` - вывод минимального значения;
* `MAX` - вывод максимального значения.

Чтобы включить агрегацию для таблицы данных, необходимо:

. Установить для атрибута `aggregatable` значение `true`.
. Указать элемент `aggregation` для агрегируемых колонок.
+

[[aggregation-type]]
. Указать для элемента `aggregation` атрибут `type`, задающий функцию агрегации.

Агрегированные значения выводятся в дополнительной строке.

[[aggregation-position]]
Атрибут `aggregationPosition` позволяет задать расположение строки агрегации: `TOP` или `BOTTOM`. `TOP` используется по умолчанию.

[NOTE]
====
По умолчанию в агрегируемых колонках поддерживаются только числовые типы данных, такие как `Integer`, `Double`, `Long`, и `BigDecimal`.
====

Пример описания `DataGrid` с агрегацией:

[source, xml,indent=0]
----
include::example$/ex1/src/main/resources/ui/ex1/screen/component/datagrid/data-grid-screen.xml[tags=aggregation-grid]
----

image::vcl/components/data-grid-aggregation.png[align="center"]

[[aggregation-value-description]]
Атрибут `valueDescription` задает текст всплывающей подсказки, отображаемой при наведении курсора мыши по агрегированному значению. Для операций, перечисленных выше (`SUM`, `AVG`, `COUNT`, `MIN`, `MAX`), всплывающие подсказки уже есть по умолчанию.

[[aggregation-formatter]]
Для отображения агрегированного значения в виде, отличном от стандартного для данного `Datatype`, для него можно указать xref:vcl/miscellaneous/formatter.adoc[Formatter]:

[source, xml,indent=0]
----
include::example$/ex1/src/main/resources/ui/ex1/screen/component/datagrid/data-grid-screen.xml[tags=grid-aggregation-format]
----

[[aggregation-strategy-class]]
Элемент `aggregation` может также содержать атрибут `strategyClass`, указывающий класс, реализующий интерфейс `AggregationStrategy`.

[source,java,indent=0]
----
include::example$/ex1/src/main/java/ui/ex1/screen/component/datagrid/CustomerHobbyAggregation.java[tags=aggregation-strategy]
----

[source,xml,indent=0]
----
include::example$/ex1/src/main/resources/ui/ex1/screen/component/datagrid/data-grid-screen.xml[tags=grid-aggregation-strategy]
----

[[grid-sorting]]
== Сортировка

`DataGrid` позволяет пользователям сортировать данные колонки. Функция сортировки включена по умолчанию.

Атрибут `sortable` позволяет сортировать данные в таблице. По умолчанию имеет значение `true`. Если сортировка разрешена, при щелчке по заголовку колонки появится image:vcl/components/table-sortable-down.png[]/image:vcl/components/table-sortable-up.png[]значок справа от названия колонки.

[[column-sortable]]
Можно отключить сортировку для конкретной <<column,колонки>>, используя ее атрибут `sortable`.

В примере ниже отключим сортировку по колонке `lastName`:

[source, xml,indent=0]
----
include::example$/ex1/src/main/resources/ui/ex1/screen/component/datagrid/data-grid-screen.xml[tags=grid-sorting]
----

[[column-sort]]

Атрибут `sort` элемента `column` позволяющий задать начальную сортировку таблицы по указанной колонке в соответствии с направлением сортировки. Возможные значения:

* `ASCENDING` - сортировка по возрастанию (0 -> 9 -> A -> Z).
* `DESCENDING` -  сортировка по убыванию (Z -> A -> 9 -> 0).

Например:

[source, xml,indent=0]
----
include::example$/ex1/src/main/resources/ui/ex1/screen/component/datagrid/data-grid-screen.xml[tags=grid-sort]
----

[CAUTION]
====
В одно и то же время таблица `DataGrid` может быть сортирована только по одной колонке. Если установить атрибут `sort` для нескольких колонок или установить для колонки атрибуты `sort` и `sortable="false"` одновременно, это вызовет исключение.
====

События сортировки `DataGrid` можно отслеживать с помощью <<sort-event,SortEvent>>.

[[paging]]
== Разбивка на страницы

Компонент xref:vcl/components/simple-pagination.adoc[] может быть использован внутри `dataGrid` для обеспечения разбивки на страницы:

[source, xml,indent=0]
----
include::example$/ex1/src/main/resources/ui/ex1/screen/component/datagrid/data-grid-screen.xml[tags=grid-paging]
----

image::vcl/components/data-grid-pagination.png[align="center"]

В качестве альтернативы можно использовать отдельный компонент xref:vcl/components/pagination.adoc[].

[[actions]]
== Действия DataGrid

Компонент `DataGrid` реализует интерфейс `ActionsHolder` и может содержать настраиваемые действия и xref:actions/standard-actions.adoc#list-actions[стандартные действия с коллекцией].

Действия таблицы данных определяются во вложенном элементе `actions`.

Если действие имеет название, оно отображается как элемент <<context-menu-enabled,контекстного меню>> таблицы. Кроме того, действие таблицы данных может быть назначено кнопке, расположенной в любом месте экрана.

[[buttons-panel]]
Для отображения кнопок действий над таблицей данных можно использовать контейнер xref:vcl/containers/buttons-panel.adoc[ButtonsPanel].

[source, xml,indent=0]
----
include::example$/ex1/src/main/resources/ui/ex1/screen/component/datagrid/data-grid-screen.xml[tags=grid-actions-buttons-panel]
----
<1> Определение стандартного действия `create`.
<2> Определение настраиваемого действия `about`.
<3> Определение контейнера `ButtonsPanel` в таблице данных.

image::vcl/components/data-grid-actions.png[align="center"]

[[data-grid-column-generation]]
== Генерация колонок

Слушатель `ColumnGeneratorEvent` позволяет добавлять генерируемые, или высчитываемые, колонки и задавать собственное отображение данных в колонке.

Слушатель вызывается фреймворком для каждой ячейки при рендере таблицы данных. `ColumnGeneratorEvent` хранит информацию о сущности, которая отображается в текущей строке `DataGrid`, и идентификатор колонки.

Слушателя `ColumnGeneratorEvent` для колонки таблицы можно создать с помощью Studio. Для этого следует выбрать генерируемый тип из списка, предложенного Studio, и соответствующий тип <<renderers,рендерера>>.

В качестве примера создадим генерированную колонку, содержащую полное имя клиента.

Сначала создайте колонку с id `fullName`:

[source, xml,indent=0]
----
include::example$/ex1/src/main/resources/ui/ex1/screen/component/datagrid/data-grid-screen.xml[tags=text-renderer]
----

Затем создайте слушателя `ColumnGeneratorEvent` для колонки `fullName` с помощью Studio и реализуйте его следующим образом:

[source,java,indent=0]
----
include::example$/ex1/src/main/java/ui/ex1/screen/component/datagrid/DataGridScreen.java[tags=column-generator]
----

Результат:

image::vcl/components/data-grid-generated-column.png[align="center"]

Колонка `fullName` является генерированной колонкой с <<text-renderer,TextRenderer>>.

Чтобы создать слушателя генератора колонок программно, используйте метод `addGeneratedColumn()` вместо компонента `DataGrid`.

[[exporting-column-values]]
== Экспорт значений колонок

Чтобы экспортировать содержимое компонента `DataGrid` в виде файла в одном из поддерживаемых форматов, используйте дополнение xref:grid-export:index.adoc[Grid Export Actions].

После установки дополнения вы можете определить для таблицы действие xref:grid-export:actions.adoc#excel-export-action[excelExport] или xref:grid-export:actions.adoc#json-export-action[jsonExport] или использовать xref:grid-export:exporters.adoc[TableExporter].

Ниже приведен пример настройки пользовательского представления данных в колонке при экспорте в файл XLS с помощью действия `excelExport`.

Дескриптор экрана:

[source, xml,indent=0]
----
include::example$/ex1/src/main/resources/ui/ex1/screen/component/datagrid/data-grid-screen.xml[tags=grid-export-start;grid-export-end]
----

Контроллер экрана:

[source,java,indent=0]
----
include::example$/ex1/src/main/java/ui/ex1/screen/component/datagrid/DataGridScreen.java[tags=inject-grid-excel-export;init-start;add-column-value-provider;init-end]
----

<1> Метод принимает идентификатор колонки и функцию для получения значения из колонки.

[[renderers]]
== Рендереры

Отображение данных в колонках может быть изменено с помощью параметризованных декларативных рендереров. Некоторые рендереры `DataGrid` задаются специальными XML-элементами с параметрами, определенными в соответствующих атрибутах. Рендереры могут быть объявлены также и для не генерируемых колонок.

Список рендереров, поддерживаемых фреймворком:

* <<button-renderer,ButtonRenderer>>
* <<image-renderer,ImageRenderer>>
* <<check-box-renderer,CheckBoxRenderer>>
* <<number-renderer,NumberRenderer>>
* <<local-date-time-renderer,LocalDateTimeRenderer>>
* <<local-date-renderer,LocalDateRenderer>>
* <<date-renderer,DateRenderer>>
* <<progress-bar-renderer,ProgressBarRenderer>>
* <<html-renderer,HtmlRenderer>>
* <<clickable-text-renderer,ClickableTextRenderer>>
* <<text-renderer,TextRenderer>>
* <<component-renderer,ComponentRenderer>>
* <<icon-renderer,IconRenderer>>

[[button-renderer]]
=== ButtonRenderer

`ButtonRenderer` – рендерер для отображения строкового значения в качестве заголовка кнопки.

`ButtonRenderer` не может быть объявлен в XML-дескрипторе, так как в нем невозможно определить слушатель отслеживания кликов по кнопке. Studio сгенерирует код объявления `ButtonRenderer` в методе `onInit()` контроллера экрана, например:

[source,java,indent=0]
----
include::example$/ex1/src/main/java/ui/ex1/screen/component/datagrid/DataGridScreen.java[tags=inject-gridButtonRenderer;inject-notifications;init-start;button-renderer;init-end]
----

image::vcl/components/data-grid-button-renderer.png[align="center"]

[[image-renderer]]
=== ImageRenderer

`ImageRenderer` – рендерер для отображения изображений. Значение соответствующего свойства используется в качестве местоположения изображения. Местоположение может быть ресурсом темы или URL-адресом.

`ImageRenderer` не может быть объявлен в XML-дескрипторе, так как в нем невозможно определить слушатель отслеживания кликов по кнопке. Studio сгенерирует код объявления `ImageRenderer` в методе `onInit()` контроллера экрана, например:

[source,java,indent=0]
----
include::example$/ex1/src/main/java/ui/ex1/screen/component/datagrid/DataGridScreen.java[tags=inject-imageGrid;inject-notifications;init-start;image-renderer;init-end]
----

Результат:

image::vcl/components/data-grid-image-renderer.png[align="center"]

[[check-box-renderer]]
=== CheckBoxRenderer

`CheckBoxRenderer` отображает булево значение в виде значков чек-бокса.

Элемент `column` компонента `DataGrid` имеет вложенный элемент `checkBoxRenderer`:

[source, xml,indent=0]
----
include::example$/ex1/src/main/resources/ui/ex1/screen/component/datagrid/data-grid-screen.xml[tags=grid-check-box-renderer]
----

[[number-renderer]]
=== NumberRenderer

`NumberRenderer` отображает числа в заданном формате.

Элемент `column` компонента `DataGrid` имеет вложенный элемент `numberRenderer` с необязательным атрибутом `nullRepresentation` и обязательным строковым атрибутом `format`:

[source, xml,indent=0]
----
include::example$/ex1/src/main/resources/ui/ex1/screen/component/datagrid/data-grid-screen.xml[tags=grid-number-renderer]
----

`formatString` – это строка формата, описывающая формат чисел, который будет использоваться для создания экземпляра `NumberFormat`.

[[local-date-time-renderer]]
=== LocalDateTimeRenderer

`LocalDateTimeRenderer` отображает даты как значения `LocalDateTime`.

Элемент `column` компонента `DataGrid` имеет вложенный элемент `localDateTimeRenderer` с необязательным атрибутом `nullRepresentation` и обязательным строковым атрибутом `format`:

[source, xml,indent=0]
----
include::example$/ex1/src/main/resources/ui/ex1/screen/component/datagrid/data-grid-screen.xml[tags=grid-local-date-time-renderer]
----

[[local-date-renderer]]
=== LocalDateRenderer

`LocalDateRenderer` отображает даты как значения `LocalDate` values.

Элемент `column` компонента `DataGrid` имеет вложенный элемент `localDateRenderer` с необязательным атрибутом `nullRepresentation` и обязательным строковым атрибутом `format`:

[source, xml,indent=0]
----
include::example$/ex1/src/main/resources/ui/ex1/screen/component/datagrid/data-grid-screen.xml[tags=grid-local-date-renderer]
----

Результат:

image::vcl/components/data-grid-local-date-renderer.png[align="center"]

[[date-renderer]]
=== DateRenderer

`DateRenderer` отображает даты в заданном формате.

Элемент `column` компонента `DataGrid` имеет вложенный элемент `dateRenderer` с необязательным атрибутом `nullRepresentation` и обязательным строковым атрибутом `format`:

[source, xml,indent=0]
----
include::example$/ex1/src/main/resources/ui/ex1/screen/component/datagrid/data-grid-screen.xml[tags=grid-date-renderer]
----

`formatString` – это строка формата, описывающая формат чисел, который будет использоваться для создания экземпляра `DateFormat`.

image::vcl/components/data-grid-date-renderer.png[align="center"]

Обратите внимание, что поле `startDate` имеет `DateRenderer`, а поле `endDate` – нет.

[[progress-bar-renderer]]
=== ProgressBarRenderer

`ProgressBarRenderer` отображает `double`-значения от 0 до 1 в виде компонента `ProgressBar`.

Элемент `column` компонента `DataGrid` имеет вложенный элемент `progressBarRenderer`:

[source, xml,indent=0]
----
include::example$/ex1/src/main/resources/ui/ex1/screen/component/datagrid/data-grid-screen.xml[tags=grid-progress-bar-renderer]
----

Результат:

image::vcl/components/data-grid-progress-bar-renderer.png[align="center"]

[[html-renderer]]
=== HtmlRenderer

`HtmlRenderer` отображает HTML-разметку.

Элемент `column` компонента `DataGrid` имеет вложенный элемент `htmlRenderer` с необязательным атрибутом `nullRepresentation`.

Ниже приведен пример рендеринга атрибута `endDate`:

[source, xml,indent=0]
----
include::example$/ex1/src/main/resources/ui/ex1/screen/component/datagrid/data-grid-screen.xml[tags=grid-html-renderer]
----

[source,java,indent=0]
----
include::example$/ex1/src/main/java/ui/ex1/screen/component/datagrid/DataGridScreen.java[tags=html-renderer]
----

Результат:

image::vcl/components/data-grid-html-renderer.png[align="center"]

[[clickable-text-renderer]]
=== ClickableTextRenderer

`ClickableTextRenderer` отображает простой текст в виде ссылки со слушателем кликов.

`ClickableTextRenderer` не может быть объявлен в XML-дескрипторе, так как в нем невозможно определить слушатель отслеживания кликов по кнопке. Studio сгенерирует код объявления `ClickableTextRenderer` в методе `onInit()` контроллера экрана, например:

[source,java,indent=0]
----
include::example$/ex1/src/main/java/ui/ex1/screen/component/datagrid/DataGridScreen.java[tags=inject-gridClick;inject-notifications;init-start;clickable-text-renderer;init-end]
----

Результат:

image::vcl/components/data-grid-click-text-renderer.gif[align="center"]

[[text-renderer]]
=== TextRenderer

`TextRenderer` отображает простой текст.

Элемент `column` компонента `DataGrid` имеет вложенный элемент `textRenderer` с необязательным атрибутом `nullRepresentation`:

[source, xml,indent=0]
----
include::example$/ex1/src/main/resources/ui/ex1/screen/component/datagrid/data-grid-screen.xml[tags=text-renderer]
----

[[component-renderer]]
=== ComponentRenderer

`ComponentRenderer` – рендерер для компонентов UI.

Элемент `column` компонента `DataGrid` имеет вложенный элемент `componentRenderer`:

[source, xml,indent=0]
----
include::example$/ex1/src/main/resources/ui/ex1/screen/component/datagrid/data-grid-screen.xml[tags=grid-component-renderer]
----

В приведенном ниже примере отобразим значение `age` в компоненте `Slider`.

[source,java,indent=0]
----
include::example$/ex1/src/main/java/ui/ex1/screen/component/datagrid/DataGridScreen.java[tags=component-renderer]
----

Результат:

image::vcl/components/data-grid-component-renderer.png[align="center"]

[[icon-renderer]]
=== IconRenderer

`IconRenderer` – рендерер, который представляет `JmixIcon`.

Элемент `column` компонента `DataGrid` имеет вложенный элемент `iconRenderer`.

Ниже приведен пример рендеринга сгенерированного атрибута `hasEmail`:

[source, xml,indent=0]
----
include::example$/ex1/src/main/resources/ui/ex1/screen/component/datagrid/data-grid-screen.xml[tags=grid-icon-renderer]
----

[source,java,indent=0]
----
include::example$/ex1/src/main/java/ui/ex1/screen/component/datagrid/DataGridScreen.java[tags=icon-renderer]
----

Результат:

image::vcl/components/data-grid-icon-renderer.png[align="center"]

[[item-details-generator]]
== Генератор Item Details

Item details (подробности) – это раскрываемые области содержимого, используемые для отображения дополнительной информации для определенной строки.

Интерфейс `DetailsGenerator` позволяет создать настраиваемый компонент для отображения подробностей.

Можно создать слушателя `DetailsGenerator` для `DataGrid` с помощью Studio (см. <<handlers,ниже>>) и реализовать его следующим образом:

[source,java,indent=0]
----
include::example$/ex1/src/main/java/ui/ex1/screen/component/datagrid/DataGridScreen.java[tags=inject-detailsGrid;details-generator;create-close-button;get-content]
----

Для отслеживания отображения и скрытия подробностей нужно реализовать свой собственный слушатель. Например, в данном примере отслеживается отображение подробностей в `ItemClickAction` компонента `DataGrid`:

[source,java,indent=0]
----
include::example$/ex1/src/main/java/ui/ex1/screen/component/datagrid/DataGridScreen.java[tags=item-click-event]
----

Результат:

image::vcl/components/data-grid-detail-generator.png[align="center"]

[[editing]]
== Редактирование значений

[[editor-enabled]]
`DataGrid` обеспечивает внутристрочное редактирование, которое позволяет пользователям манипулировать данными таблицы. Чтобы включить внутристрочное редактирование, установите для атрибута `editorEnabled` значение `true`.

=== Использование

* Внутристрочное редактирование активируется при двойном щелчке по редактируемому полю или нажатии *Enter*, когда редактируемая ячейка находится в фокусе.

[[column-editable]]
* Колонки с атрибутом `editable = true` показывают компоненты для редактирования атрибутов соответствующей сущности. Не редактируемые поля будут отключены.
* Тип компонента для каждой редактируемой колонки выбирается автоматически на основе типа соответствующего атрибута сущности. Например, для строковых и числовых атрибутов приложение будет использовать xref:vcl/components/text-field.adoc[TextField], для `Date` – xref:vcl/components/date-field.adoc[DateField], для перечислений – xref:vcl/components/combo-box.adoc[ComboBox], для ссылок на другие сущности – xref:vcl/components/entity-picker.adoc[EntityPicker].
* Как только строка станет доступной для редактирования, рядом со строкой появятся кнопки по умолчанию *OK* и *Cancel*, позволяющие пользователям завершить или отменить редактирование.
* Чтобы сохранить изменения и выйти из режима редактирования, нажмите *OK* или клавишу *Enter*.
* Чтобы отменить изменения и выйти из режима редактирования, нажмите кнопку *Cancel* или клавишу *Esc*.

image::vcl/components/data-grid-editing.png[align="center"]

[[editor-buffered]]
=== Режимы

Редактирование может быть как буферизованным, так и небуферизованным.

* В буферизованном режиме изменения должны быть явно зафиксированы.
* Редактирование без буферизации автоматически фиксирует изменения, когда поле теряет фокус.

Атрибут `editorBuffered` задает режим буферизованного редактирования. Значение по умолчанию – `true`.

Изменения сохраняются только в контейнере данных. Сохранение изменений в базе данных обычно выполняется с помощью xref:data/data-context.adoc[] на экране коммита.

=== Настройка внутристрочного редактора

[[editor-cancel-caption]]
Атрибут `editorCancelCaption` устанавливает заголовок кнопки отмены в режиме редактирования `DataGrid`.

[[editor-save-caption]]
The `editorSaveCaption` устанавливает заголовок кнопки сохранения изменений в режиме редактирования `DataGrid`.

[[edit-field-generator]]
Само поле редактирования может быть изменено с помощью класса `EditorFieldGenerationContext`.

Создайте генератор полей редактирования, который генерирует компонент для этой колонки в редакторе `DataGrid`, например:

[source,java,indent=0]
----
include::example$/ex1/src/main/java/ui/ex1/screen/component/datagrid/DataGridScreen.java[tags=inject-citiesDc;edit-field-generator]
----

Результат:

image::vcl/components/data-grid-edit-field-generator.png[align="center"]

Существует также декларативный способ определения того, какой компонент использовать для выбора сущности в системных механизмах. Он основан на свойствах xref:app-properties.adoc#jmix.ui.component.entity-field-type[jmix.ui.component.entity-field-type] и xref:app-properties.adoc#jmix.ui.component.entity-field-actions[jmix.ui.component.entity-field-actions].

Например, если добавить следующие строки в файл `application.properties`:

[source,properties]
----
jmix.ui.component.entity-field-type.uiex1_City = entityComboBox
jmix.ui.component.entity-field-actions.uiex1_City = entity_lookup, entity_open, entity_clear
----

Тогда компонент `EntityComboBox` будет сгенерирован для сущности `City`:

image::vcl/components/data-grid-editable-custom-field.png[align="center"]

[[editor-cross-field-validate]]
=== Перекрестная проверка полей

Внутристрочный редактор `DataGrid` может учитывать ограничения сущностей (перекрестная проверка полей). Если есть ошибки валидации, `DataGrid` покажет сообщение об ошибке. Чтобы включить или отключить проверку, используйте атрибут `editorCrossFieldValidate`. Значение по умолчанию – `true`

=== События редактора

События редактора предоставляют доступ к компонентам, используемым в редакторе, позволяя изменять или использовать их значения.

[[editor-open-event]]
* `EditorOpenEvent` посылается перед открытием редактора `DataGrid`.
+
Например:
+
[source,java,indent=0]
----
include::example$/ex1/src/main/java/ui/ex1/screen/component/datagrid/DataGridScreen.java[tags=editor-open-event]
----

[[editor-close-event]]
* `EditorCloseEvent` посылается при закрытии редактора `DataGrid`.

[[editor-pre-commit-event]]
* `EditorPreCommitEvent` посылается перед сохранением записи.

[[editor-post-commit-event]]
* `EditorPostCommitEvent` посылается после сохранения записи.

=== Методы редактора

[[method-get-edited-item]]
* `getEditedItem()` возвращает редактируемую запись или `null`, если в данный момент ни одна запись не редактируется.

[[method-is-editor-active]]
* `isEditorActive()` возвращает `true`, если в момент вызова редактируется какая-либо запись.

[[method-edit]]
* Метод `edit()` открывает интерфейс внутристрочного редактора для предоставленной сущности. Пролистывает таблицу до нужной записи, если в момент вызова она не была видна на экране.

[[context-menu-enabled]]
== Контекстное меню

Контекстное меню активируется щелчком правой кнопки мыши в таблице данных.

Атрибут `contextMenuEnabled` включает или выключает контекстное меню. По умолчанию имеет значение `true`. В контекстном меню отображаются <<actions,действия DataGrid>> (если таковые имеются).

Щелчки правой кнопкой мыши по области компонента `DataGrid` можно отслеживать с помощью слушателя <<context-click-event,ContextClickEvent>>.

[[stylename]]
== Стили

Компоненту `DataGrid` можно задать предопределенные стили с помощью атрибута `stylename` в XML-дескрипторе или в контроллере экрана.

[source, xml,indent=0]
----
include::example$/ex1/src/main/resources/ui/ex1/screen/component/datagrid/data-grid-screen.xml[tags=grid-stylename]
----

[source,java,indent=0]
----
include::example$/ex1/src/main/java/ui/ex1/screen/component/datagrid/DataGridScreen.java[tags=set-style-name]
----

Предопределенные стили:

* `borderless` - удаляет внешнюю рамку;
* `no-horizontal-lines` - удаляет горизонтальные строковые разделители;
* `no-vertical-lines` - удаляет вертикальные разделители колонок;
* `no-stripes` - отключает чередование цветов строк таблицы.

Внешний вид компонента `DataGrid` можно настроить с помощью переменных SCSS с префиксом `$jmix-datagrid-*`. Эти переменные можно изменить в визуальном редакторе после создания xref:themes/custom_theme.adoc[новой темы].

См. также <<row-style-provider>>.

[[methods]]
== Методы интерфейса DataGrid

[[methods-get-columns]]
* `getColumns()` возвращает копию текущего набора колонок `DataGrid` в порядке их текущего отображения.

[[methods-get-visible-columns]]
* `getVisibleColumns()` возвращет копию набора колонок `DataGrid`, не скрытых разрешениями безопасности.

[[methods-sort]]
* Метод `sort()` <<grid-sorting,сортирует>> данные в переданной колонке в заданном направлении.

[[methods-scroll-to]]
* `scrollTo()` позволяет прокрутить `DataGrid` до указанной строки. Метод принимает экземпляр сущности, определяющий нужную строку. Перегруженный метод, помимо сущности, принимает `ScrollDestination`, имеющий следующие возможные значения:

** `ANY` - прокрутить как можно меньше, чтобы показать нужную запись. Если запись помещается в видимую область, работает как `START` и `END`, в зависимости от текущего положения прокрутки. Если запись не помещается в видимую область, работает как START`.
** `START` - прокрутить так, чтобы нужная запись оказалась в начале видимой области. Однако область просмотра не будет прокручиваться за пределы своего содержимого.
** `MIDDLE` - прокрутить так, чтобы нужная запись оказалась в центре видимой области. Однако область просмотра не будет прокручиваться за пределы своего содержимого, учитывая большее количество записей, чем то, что область просмотра может отображать одновременно. Ни при каких обстоятельствах область просмотра не будет прокручиваться выше своей первой записи.
** `END` - прокрутить так, чтобы нужная запись оказалась в конце видимой области. Однако область просмотра не будет прокручиваться выше своей первой записи.

[[methods-scroll-to-start-end]]
* `scrollToStart()` и `scrollToEnd()` позволяют прокрутить `DataGrid` до первой и последней записи соответственно.

[[methods-get-aggregation-results]]
* Метод `getAggregationResults()` возвращает мэп с результатами <<aggregatable,агрегации>>, где ключи в мэп – идентификаторы колонок `DataGrid`, а значения – значения агрегации.

[[handlers]]
== События и слушатели

include::../events-hanlers-generation-tip.adoc[]

[[column-collapsing-change-event]]
=== ColumnCollapsingChangeEvent

`ColumnCollapsingChangeEvent` отправляется при изменении <<column-collapsing,сворачивания>> колонки.

Пример подписки на событие таблицы, объявленного в XML с идентификатором `collapseGrid`:

[source,java,indent=0]
----
include::example$/ex1/src/main/java/ui/ex1/screen/component/datagrid/DataGridScreen.java[tags=column-collapsing-change-event]
----

Чтобы создать слушателя события программно, используйте метод компонента `addColumnCollapsingChangeListener()`.

[[column-reorder-event]]
=== ColumnReorderEvent

См. xref:vcl/components/table.adoc#column-reorder-event[ColumnReorderEvent].

[[column-resize-event]]
=== ColumnResizeEvent

`ColumnResizeEvent` отправляется при <<column-resizable,изменении размера>> колонки.

Пример подписки на событие таблицы, объявленного в XML с идентификатором `resizedEventGrid`:

[source,java,indent=0]
----
include::example$/ex1/src/main/java/ui/ex1/screen/component/datagrid/DataGridScreen.java[tags=column-resize-event]
----

Чтобы создать слушателя события программно, используйте метод компонента `addColumnResizeListener()`.

[[context-click-event]]
=== ContextClickEvent

`ContextClickEvent` отправляется при щелчке правой кнопкой мыши в `DataGrid`.

`ContextClickEvent` содержит информацию о событии мыши.

Пример подписки на событие таблицы, объявленного в XML с идентификатором `contextGrid`:

[source,java,indent=0]
----
include::example$/ex1/src/main/java/ui/ex1/screen/component/datagrid/DataGridScreen.java[tags=context-click-event]
----

Чтобы создать слушателя события программно, используйте метод компонента `addContextClickListener()`.

=== EditorCloseEvent

См. <<editor-close-event,EditorCloseEvent>>.

=== EditorOpenEvent

См. <<editor-open-event,EditorOpenEvent>>.

=== EditorPostCommitEvent

См. <<editor-post-commit-event,EditorPostCommitEvent>>.

=== EditorPreCommitEvent

См. <<editor-pre-commit-event,EditorPreCommitEvent>>.

[[item-click-event]]
=== ItemClickEvent

`ItemClickEvent` отправляется при клике пользователем по таблице данных. `ItemClickEvent` содержит информацию о:

* Подробностях события мыши;
* Экземпляр сущности, представленный кликнутой строкой;
* `id` записи;
* `id` кликнутой колонки `DataGrid`.

В качестве примера дадим пользователю возможность начать <<editing,редактирование>> одним щелчком мыши по редактируемой ячейке:

[source,java,indent=0]
----
include::example$/ex1/src/main/java/ui/ex1/screen/component/datagrid/DataGridScreen.java[tags=item-click-event2]
----

Чтобы создать слушателя события программно, используйте метод компонента `addItemClickListener()`.

[[selection-event]]
=== SelectionEvent

См. xref:vcl/components/table.adoc#selection-event[SelectionEvent].

[[sort-event]]
=== SortEvent

`SortEvent` отправляется при изменении <<grid-sorting,сортировки>>.

Пример подписки на событие таблицы, объявленного в XML с идентификатором `sortGrid` id:

[source,java,indent=0]
----
include::example$/ex1/src/main/java/ui/ex1/screen/component/datagrid/DataGridScreen.java[tags=sort-event]
----

Чтобы создать слушателя события программно, используйте метод компонента `addSortListener()`.

[[context-help-icon-click-handler]]
=== ContextHelpIconClickHandler

См. xref:vcl/api.adoc#context-help-icon-click-handler[ContextHelpIconClickHandler].

[[details-generator]]
=== DetailsGenerator

См. <<item-details-generator,DetailsGenerator>>.

[[empty-state-link-click-handler]]
=== EmptyStateLinkClickHandler

См. xref:vcl/components/table.adoc#empty-state-click-event[EmptyStateLinkClickHandler].

[[lookup-select-handler]]
=== LookupSelectHandler

См. xref:vcl/components/table.adoc#lookup-select-handler[LookupSelectHandler].

[[row-description-provider]]
=== RowDescriptionProvider

`RowDescriptionProvider` генерирует всплывающие подсказки, когда пользователь наводит курсор на строку `DataGrid`. Если для колонки также задан `DescriptionProvider`, то описание строки, сгенерированное `RowDescriptionProvider`, используется для ячеек, для которых `DescriptionProvider` возвращает `null`.

В приведенном ниже примере показано использование `RowDescriptionProvider` для `rowDescGrid`:

[source,java,indent=0]
----
include::example$/ex1/src/main/java/ui/ex1/screen/component/datagrid/DataGridScreen.java[tags=row-description-provider]
----

Результат:

image::vcl/components/data-grid-row-description.gif[align="center"]

Чтобы создать слушателя события программно, используйте метод компонента `setRowDescriptionProvider()`.

[[row-style-provider]]
=== RowStyleProvider

`RowStyleProvider` позволяет добавить стиль отображения строк `DataGrid`.
`DataGrid` может получать несколько имен стилей для строк, используя несколько провайдеров.

Пример установки стиля:

[source,java,indent=0]
----
include::example$/ex1/src/main/java/ui/ex1/screen/component/datagrid/DataGridScreen.java[tags=row-style-provider]
----

После этого следует определить стили строк в теме приложения. Подробная информация о создании темы доступна в разделе xref:themes.adoc[Темы]. Имена стилей, возвращаемые провайдером в контроллере экрана, должны использоваться в качестве селекторов CSS. Например:

[source,css,indent=0]
----
include::example$/ex1/src/main/themes/helium-extended/helium-extended.scss[tags=grid-rows-style]
----

Результат:

image::vcl/components/data-grid-row-style.png[align="center"]

[[xml]]
== Все XML-атрибуты

include::../xml-studio-tip.adoc[]

=== XML-атрибуты DataGrid

<<aggregatable,aggregatable>> -
<<aggregation-position,aggregationPosition>> -
xref:vcl/xml.adoc#align[align] -
<<body-row-height,bodyRowHeight>> -
xref:vcl/xml.adoc#box-expand-ratio[box.expandRatio] -
xref:vcl/xml.adoc#caption[caption] -
xref:vcl/xml.adoc#caption-as-html[captionAsHtml] -
xref:vcl/xml.adoc#colspan[colspan] -
<<column-resize-mode,columnResizeMode>> -
<<column-collapsing-allowed,columnCollapsingAllowed>> -
xref:vcl/xml.adoc#context-help-text[contextHelpText] -
xref:vcl/xml.adoc#context-help-text-html-enabled[contextHelpTextHtmlEnabled] -
<<context-menu-enabled,contextMenuEnabled>> -
xref:vcl/xml.adoc#css[css] -
xref:vcl/xml.adoc#data-container[dataContainer] -
xref:vcl/xml.adoc#description[description] -
xref:vcl/xml.adoc#description-as-html[descriptionAsHtml] -
<<editor-buffered,editorBuffered>> -
<<editor-cancel-caption,editorCancelCaption>> -
<<editor-cross-field-validate,editorCrossFieldValidate>> -
<<editor-enabled,editorEnabled>> -
<<editor-save-caption,editorSaveCaption>> -
<<empty-state-link-message,emptyStateLinkMessage>> -
<<empty-state-message,emptyStateMessage>> -
xref:vcl/xml.adoc#enable[enable] -
<<footer-row-height,footerRowHeight>> -
<<footer-visible,footerVisible>> -
<<column-freezing,frozenColumnCount>> -
<<header-row-height,headerRowHeight>> -
<<header-visible,headerVisible>> -
xref:vcl/xml.adoc#height[height] -
xref:vcl/xml.adoc#html-sanitizer-enabled[htmlSanitizerEnabled] -
xref:vcl/xml.adoc#icon[icon] -
xref:vcl/xml.adoc#id[id] -
<<meta-class,metaClass>> -
<<min-height,minHeight>> -
<<min-width,minWidth>> -
<<reordering-allowed,reorderingAllowed>> -
xref:vcl/xml.adoc#responsive[responsive] -
xref:vcl/xml.adoc#rowspan[rowspan] -
<<selection-mode,selectionMode>> -
<<grid-sorting,sortable>> -
<<stylename,stylename>> -
xref:vcl/xml.adoc#tab-index[tabIndex] -
<<text-selection-enabled,textSelectionEnabled>> -
xref:vcl/xml.adoc#visible[visible] -
xref:vcl/xml.adoc#width[width]

[[xml-data-grid-elements]]
=== XML-элементы DataGrid

<<actions,actions>> -
<<buttons-panel,buttonsPanel>> -
<<columns,columns>> -
<<paging,simplePagination>>

=== XML-атрибуты Columns

<<exclude,exclude>> -
<<include-all,include-all>>

=== XML-атрибуты Column

xref:vcl/xml.adoc#box-expand-ratio[box.expandRatio] -
<<column-caption,caption>> -
<<column-collapsed,collapsed>> -
<<column-collapsible,collapsible>> -
<<collapsing-toggle-caption,collapsingToggleCaption>> -
xref:vcl/xml.adoc#colspan[colspan] -
<<column-editable,editable>> -
<<column-expand-ratio,expandRatio>> -
<<column-id,id>> -
<<column-maximum-width,maximumWidth>> -
<<column-minimum-width,minimumWidth>> -
<<column-property,property>> -
<<column-resizable,resizable>> -
xref:vcl/xml.adoc#rowspan[rowspan] -
<<column-sort,sort>> -
<<column-sortable,sortable>> -
<<column-width,width>>

=== XML-элементы Column

<<aggregatable,aggregation>> -
<<check-box-renderer,checkBoxRenderer>> -
<<component-renderer,componentRenderer>> -
<<date-renderer,dateRenderer>> -
<<html-renderer,htmlRenderer>> -
<<icon-renderer,iconRenderer>> -
<<local-date-renderer,localDateRenderer>> -
<<local-date-time-renderer,localDateTimeRenderer>> -
<<number-renderer,numberRenderer>> -
<<progress-bar-renderer,progressBarRenderer>> -
<<text-renderer,textRenderer>>

=== XML-атрибуты Aggregation

<<aggregation-strategy-class,strategyClass>> -
<<aggregation-type,type>> -
<<aggregation-value-description,valueDescription>>

=== XML-элемент Aggregation

<<aggregation-formatter,formatter>>

== API

<<method-edit,edit>> -
<<methods-get-aggregation-results,getAggregationResults>> -
<<methods-get-columns,getColumns>> -
<<method-get-edited-item,getEditedItem>> -
<<methods-get-visible-columns,getVisibleColumns>> -
<<method-is-editor-active,isEditorActive>> -
<<methods-scroll-to,scrollTo>> -
<<methods-scroll-to-start-end,scrollToEnd>> -
<<methods-scroll-to-start-end,scrollToStart>> -
xref:vcl/components/table.adoc#methods-set-enter-press-action[setEnterPressAction] -
xref:vcl/components/table.adoc#methods-set-item-click-action[setItemClickAction] -
<<methods-sort,sort>>