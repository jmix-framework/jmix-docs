[[examples]]
= 报表示例

[[example_xls]]
== XLS 报表

本示例基于 *Library（图书馆）* 应用程序，请按照 xref:getting-started.adoc#project_setup_report[说明] 设置应用程序并创建实体和视图。

在本示例中，我们将创建关于书籍作者的一个报表。给定一个作者，报表中列举他的所有书籍、每本书的出版商，以及该书本保存在图书馆的哪个部门，还有每个部门中保存了多少本。结果如下：

image::sample1_result.png[align="center"]

. 报表数据结构
+
--
image::sample1-structure.png[align="center",width="977"]

报表带区如下：

* *header* 带区，报表头。包含带有 Groovy 脚本的数据集，该脚本输出报表 xref:creation/parameters.adoc[外部参数]：
+
[source, groovy,indent=0]
----
return [['authorName' : (params['author'].firstName + ' ' + params['author'].lastName)]]
----

* *book* 带区通过执行以下 SQL 查询输出书籍列表：
+
[source,sql,indent=0]
----
select b.name as book_name, b.id as book_id
from BOOK b
    join BOOK_AUTHOR_LINK ba on ba.book_id = b.id
    join AUTHOR a on a.id = ba.author_id
where a.id = ${author}
----
+
此查询使用外部报表参数 - `author`。该参数是 *Entity* 类型，但在 SQL 查询中，可以直接将其与实体标识符字段进行比较；类型转换会自动完成。

* *publisher* 带区是 *book* 的子带区，通过执行以下 SQL 查询输出图书出版商：
+
[source,sql,indent=0]
----
select p.name as publisher, bp.year_, p.id as publisher_id
from BOOK_PUBLICATION bp
    join PUBLISHER p on p.id = bp.publisher_id
where bp.book_id = ${book.book_id}
----
+
此查询使用父带区字段 `++book_id++` 作为参数。以这种方式指定了父带区和子带区之间的依赖关系。

* *publication* 带区是 *publisher* 带区的子带区，通过执行以下 SQL 查询输出图书出版物：
+
[source,sql,indent=0]
----
select ld.name as department, sum(bi.book_count) as amount
from BOOK_INSTANCE bi
    join BOOK_PUBLICATION bp on bp.id = bi.book_publication_id
    join LIBRARY_DEPARTMENT ld on ld.id = bi.library_department_id
where bp.publisher_id = ${publisher.publisher_id} and bp.book_id = ${book.book_id}
group by ld.name
----
+
此查询使用父带区字段作为参数 - `++book_id++` 和 `++publisher_id++`。
--

. 报表 xref:creation/parameters.adoc[参数]。
+
*Parameters（参数）* 标签页声明了一个报表的外部参数 - `Author`：
+
image::sample1-param.png[align="center",width="642"]
+
运行报表时，用户必须输入此参数。书籍作者是通过应用程序中的 `Author.list` 视图进行选择的。

. 报表 xref:creation/templates.adoc#template_xls[模板]。
+
*Templates（模板）* 标签页包含一个 XLS 模板，从 link:{attachmentsdir}/BooksByAuthor.xls[BooksByAuthor.xls] 加载。
+
image::sample1-template.png[align="center",width="641"]

可以从 *Reports（报表）* -> *Run Report（运行报表）* 视图运行该报表。

[[crosstab_xls]]
== 交叉报表

本示例基于 *Library（图书馆）* 应用程序，请按照 xref:getting-started.adoc#project_setup_report[说明] 设置应用程序并创建实体和视图。

本示例中，我们将创建一个图书馆部门的交叉报表，列举图书馆每个部门每个月买多少本书。报表内容会向水平和垂直方向填充，并为每个部门计算每个月的数量：

image::crosstab_result.png[align="center"]

创建交叉报表时，请在报表详情视图的 xref:creation/bands.adoc[区域] 标签页上选择 *Crosstab（双向）* 带区方向。选择此方向将自动添加三个数据集：

. `<band_name>`*_dynamic_header* - 这个数据集的数据将向右复制，类似于包含表格列标题的垂直带区。

. `<band_name>`*_master_data* - 这个数据集的数据向下复制，类似于包含表格行标题的水平带区。

. `<band_name>` - 与其所属带区名称相同的数据集，是实现单元格矩阵的主内容带区。

这些数据集可以是任何支持的数据集类型：xref:creation/bands.adoc#structure_sql[SQL]、xref:creation/bands.adoc#structure_jpql[JPQL]、xref:creation/bands.adoc#structure_groovy[Groovy] 等。

例如，对于 *Library* 示例程序中 `BookInstance` 实体的交叉报表具有下列结构：

image::crosstab-structure.png[align="center",width="1145"]

. 报表数据 xref:creation/bands.adoc[结构]。有三个数据集：
+
* `bi_dynamic_header` 数据集将返回月份的名称：
+
[source, groovy,indent=0]
----
import java.text.DateFormatSymbols

List result = new ArrayList()
DateFormatSymbols dateFormatSymbols = DateFormatSymbols.getInstance(Locale.ENGLISH)
for (i in 0..dateFormatSymbols.months.length - 1) {
    result.add(["header_id" : i + 1, "month_name" : dateFormatSymbols.months[i]])
}
return result
----
+
* `bi_master_data` 数据集返回用户选择的图书馆部门的名称和 ID，这些数据以 xref:creation/parameters.adoc[外部报表参数] 的形式提供：
+
[source, sql,indent=0]
----
select name as name, id as department_id
from LIBRARY_DEPARTMENT
where id in (${selected_departments})
----
+
* `bi` 数据集为矩阵单元格提供数据，数据内容为部门每月购进的书本总数。使用 `bi_master_data@department_id`（部门 ID）作为单元格的垂直坐标，使用 `bi_dynamic_header@header_id`（月份名称）作为单元格的水平坐标，并用 `amount` 值填充对应的矩阵单元格。
+
在下面的示例中，报表还有两个外部参数：`start_date` 和 `end_date` 用于定义书籍实例创建日期的范围。最好使用 xref:creation/parameters.adoc#validation[交叉参数验证] 来确保参数值在合理的范围。
+
[source, sql,indent=0]
----
select bi.library_department_id as bi_master_data@department_id,
       month(bi.created_date) as bi_dynamic_header@header_id,
       sum(bi.book_count) as "amount"
from BOOK_INSTANCE bi
where bi.created_date >= ${start_date} and bi.created_date<= ${end_date}
and bi.library_department_id in (${bi_master_data@department_id})
and month(bi.created_date) in (${bi_dynamic_header@header_id})
group by bi.library_department_id,month(bi.created_date)
order by bi.library_department_id,month(bi.created_date)
----

. 报表 xref:creation/parameters.adoc[参数]。
+
*Parameters（参数）* 标签页包含声明的 3 个报表外部参数 - `selected_departments`，`start_date`，`end_date`：
+
image::crosstab-external-params.png[align="center",width="819"]
+
当运行报表时，用户需要输入这些参数。可以通过应用程序的 `LibraryDepartment.list` 视图选取部门。

. 报表 xref:creation/templates.adoc[模板]。
+
可以使用 *Microsoft Office* 或 *LibreOffice* 创建 XLS 报表模板。
+
模板示例：link:{attachmentsdir}/DepartmentBooks.xls[DepartmentBooks.xls]，垂直方向上输出 `Departments`，水平方向输出按月份统计的书籍数量。
+
报表模板包含交叉带区的所有三个数据集对应的 xref:creation/templates.adoc#template_xls_regions[命名区域] 以及列标题的命名区域： `<band_name>_header`。在这个例子中，是 `bi_header`。

可以在通用报表列表视图 *Reports（报表）-> *Run Reports（运行报表）* 运行。

[[example_jasper]]
== JasperReports 报表

本示例基于 *Library（图书馆）* 应用程序，请按照 xref:getting-started.adoc#project_setup_report[说明] 设置应用程序并创建实体和视图。

本示例中，我们将创建一个 JRXML 报表展示某个部门内图书出版物的列表：

image::sample_jasper_result.png[align="center"]

. 在 xref:creation/details.adoc[报表详情] 标签页，定义报表名称：`Books availability`。
. 切换至 xref:creation/bands.adoc[带区] 标签页：
+
--
image::sample-jasper-bands.png[align="center",width="1056"]

数据带区：

* *Header* band - 报表头。包含 Groovy 脚本的数据集，该脚本输出报表 xref:creation/parameters.adoc[外部参数] 值：
+
[source, groovy,indent=0]
----
return [['library_department_name' : params['library_department'].name]]
----

* *Data* 带区通过运行以下 Groovy 脚本输出书籍实例的列表，外部输入参数为部门：
+
[source, groovy,indent=0]
----
include::example$/library/src/main/resources/com/company/library/reports/bands/sample-jasper.groovy[]
----

此查询使用外部报表参数 - `library_department`。这个参数是 *Entity* 类型，但可以直接将其与实体标识符字段进行比较，类型转换会自动完成。
--

. 报表 xref:creation/parameters.adoc[参数]。
+
*Parameters（参数）* 标签页包含一个报表外部参数 - `Department`：
+
image::sample-jasper-parameter.png[align="center",width="642"]
+
运行报表时，用户必须输入此参数。部门是通过应用程序中的 `LibraryDepartment.list` 视图选择的。

. 报表 xref:creation/templates.adoc#template_jasper[模板]。
+
--
新建 JRXML 文件或者下载 link:{attachmentsdir}/BookAvailability.jrxml[BookAvailability.jrxml]，该文件包含下列内容：

[source, xml,indent=0]
----
include::example$/library/src/main/resources/com/company/library/reports/templates/BookAvailability.jrxml[]
----

这个模板中的表格与子数据集绑定。`title` 元素直接使用 *Header* 区数据。可以在 JasperReports 可视化设计器中打开模板文件来查看报表布局。

将新模板上传到应用程序，选择任何一种输出类型，并将其设置为默认值：

image::sample-jasper-template.png[align="center",width="643"]
--

可以在通用报表列表视图 *Reports（报表）-> *Run Reports（运行报表）* 运行。

// [[example_html]]
// == HTML/PDF 报表（分页/页眉页脚）

// 本示例基于 *Library（图书馆）* 应用程序，请按照 xref:getting-started.adoc#project_setup_report[说明] 设置应用程序并创建实体和视图。

// 在本示例中，我们希望创建一个关于书籍简介的报表：使用横向展示，每页带有页码、页眉和页脚，并使用特殊的 CSS 规则和属性进行配置。输出格式是 HTML 导出为 PDF：

// image::example_html_result.png[align="center"]

// . 报表 xref:creation/bands.adoc[带区]
// +
// --
// 创建一个没有参数的简易报表。使用 JPQL 查询所有书籍实体的本地属性：`name` 和 `summary`。

// image::example_html_structure.png[align="center"]
// --

// . 报表 xref:creation/templates.adoc#template_html[模板]。

// +
// --
// 现在创建报表模板文件。在这里定义页眉和页脚块，页眉和页脚会在每页 PDF 都打印。此外，需要使用特殊的 `page-break-before:always` CSS 属性，在每个书籍信息块之前生成分页符。

// 如下所示，使用 *FreeMarker* 语法将数据插入到模板中。完整的 FreeMarker 请参阅： https://freemarker.apache.org/docs/[文档^]。

// [source, html,indent=0]
// ----
// include::example$/ex2/src/main/resources/reports/ex2/docrefs/BookSummary.html[tags=html-body]
// ----
// --

// . CSS 规则
// +
// --
// 将使用以下 CSS 代码来设置页眉页脚位置：

// [source, css,indent=0]
// ----
// include::example$/ex2/src/main/resources/reports/ex2/docrefs/BookSummary.html[tags=hf-css]
// ----

// 下列 CSS 代码调整 PDF 页面展示，以及主要内容的边距以防止内容和页眉/页脚重叠：

// [source, css,indent=0]
// ----
// include::example$/ex2/src/main/resources/reports/ex2/docrefs/BookSummary.html[tags=body-css]
// ----

// 最终，完整的 link:{attachmentsdir}/BookSummary.html[BookSummary.html] 文件如下：

// [source, html,indent=0]
// ----
// include::example$/ex2/src/main/resources/reports/ex2/docrefs/BookSummary.html[tags=**]
// ----
// --

// . 创建报表模板，这里我们选择 *Freemarker* 模板类型：
// +
// --
// .模板编辑器
// image::example_html_template.png[align="center"]

// 可以在通用报表列表视图 *Reports（报表）-> *Run Reports（运行报表）* 运行。
// --

[[example_html_groovy_template]]
== HTML 报表（Groovy 模板引擎）

本示例基于 *Library（图书馆）* 应用程序，请按照 xref:getting-started.adoc#project_setup_report[说明] 设置应用程序并创建实体和视图。

本示例创建一个展示某个城市中图书出版物列表的报表。输出格式为 HTML：

image::html-groovy-result.png[align="center",width="735"]

. 使用 JPQL 数据集创建报表：
+
image::html-groovy-bands.png[align="center",width="917"]
+
`BookPublications` 区域用来输出图书出版物列表，使用如下 JPQL 查询语句：
+
[source, sql,indent=0]
----
select b.name as "book",
p.name as "publisher"
from BookPublication bp
left join bp.book b
left join bp.publisher p
where bp.city = ${city}
----
+
这个查询使用了外部的报表参数 - `city`。该参数是 *Entity* 类型。

. 报表 xref:creation/parameters.adoc[参数]：
+
在 *Parameters（参数）* 标签页声明了一个报表外部参数 - `City`：
+
image::html-groovy-parameter.png[align="center",width="642"]
+
当运行报表时，用户必须输入该参数。城市的选择会通过 `City.list` 视图进行。

. 创建报表 xref:creation/templates.adoc#template_html[模板]
+
新建一个 HTML 文件包含下列内容，或者下载 link:{attachmentsdir}/PublicationByCity.html[PublicationByCity.html] 模板：
+
[source, html,indent=0]
----
include::example$/library/src/main/resources/com/company/library/reports/templates/PublicationByCity.html[tags=**]
----
+
输入参数的值用来生成报表标题：`${Root.fields.city.name}`。
+
`bookPublications` 变量定义如下：
+
[source, groovy,indent=0]
----
include::example$/library/src/main/resources/com/company/library/reports/templates/PublicationByCity.html[tags=bookPublications]
----
+
该变量在表格体中用来显示报表字段。
+
[source, groovy,indent=0]
----
include::example$/library/src/main/resources/com/company/library/reports/templates/PublicationByCity.html[tags=report-fields]
----
+
上传新的模板，然后选择 HTML 输出类型，在 *Template type（模板类型）* 处选择 *Groovy template* 并设置为默认：
+
image::html-groovy-template.png[align="center",width="642"]

可以在通用报表列表视图 *Reports（报表）-> *Run Reports（运行报表）* 运行。
