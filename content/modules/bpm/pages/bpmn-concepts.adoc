= BPMN Concepts

[[actors]]
== Actors (Performers)

[[activities]]
== Activities


[[business-key]]
== Business Key
A business key is a way to identify a process instance based on business-specific criteria, rather than relying solely on the system-generated process instance ID.
The business key allows you to associate a process instance with a specific business entity or context.

//todo -- определиться с бизнес-ключом, чтоб задаввать его как свойство процесса
You can set up a business key as property of the start event form when selecting an _Input Dialog_ form. Any process variable can be used as a business key.

image::bpmn-subprocesses/setting-business-key.png[,300]

Business key can be updated programmatically via API:

[source,java]
----
runtimeService.updateBusinessKey("processInstanceId", "businessKey");
----

Or using `ProcessFormContext`:

[source,java]
----
processFormContext.processStarting()
        .withBusinessKey("business key")
        .saveInjectedProcessVariables()
        .start();
----


[[collaboration]]
== Collaboration

[[events-definitions]]
== Events Definitions

In BPMN, the messages and signals are a mechanism used to communicate between different elements within a business process.

Both messages and signals play a crucial role in defining the interactions and dependencies between various elements in a BPMN diagram.

Messages and signals must be defined *before* they can be used in events.

To define a message or signal in Studio, open a process model, select nothing to access the process properties and find signal and message definition sections:

image::bpmn-events/message-signal-definitions.png[,300]

In the web modeler you can find message and signal definitions in the process properties as well:

image::bpmn-events/message-signal-definitions-web.png[,300]


[[message-definition]]
=== Defining a Message
To create a message definition, you have to set its _id_ and _name_:

image::bpmn-events/define-messages.png[,450]

[[signal-definition]]
=== Defining a Signal

To create a signal definition, you have to set its _id_ and _name_; besides, you must select a _scope_ parameter, _Global_ or _Process instance_:

image::bpmn-events/define-signal.png[,550]

[[errors-definition]]
=== Errors Definition

image::bpmn-events/errors-definition.png[,400]


=== XML Representation

Message, signal, and error definitions in XML file are located usually between _<process>_ and _<diagram>_ sections.

[source, xml]
----
  </process>
  <message id="green" name="Green" /> <1>
  <message id="yellow" name="Yellow" />
  <message id="red" name="Red" />
  <signal id="ready" name="Ready" flowable:scope="global" /> <2>
  <signal id="stop" name="Stop" flowable:scope="processInstance" />
  <bpmndi:BPMNDiagram id="BPMNDiagram_process">
----
<1> - Message definition
<2> - Signal definition

[NOTE]
====
If you plan to use the same messages and signals in various processes, you have to create their definitions in each BPMN model.
====

[[errors-handling]]
== Errors Handling
//todo: review required


[[errors-catching]]
=== Errors Catching

Errors can be thrown by xref:bpmn-events.adoc#error-end-event[error end events] or programmatically.

A thrown error *MUST* be caught by an error catch event, specifically using an error boundary event or an error event subprocess. Otherwise, it causes an exception.

==== Catching Error by Boundary Event

When an error event is caught, the activity on which the boundary event is defined is destroyed, also destroying all current executions within (concurrent activities, nested subprocesses, and so on). Process execution continues following the outgoing sequence flow of the boundary event.

image::bpmn-events/error-catching-boundary.png[,300]

==== Event Subprocess Priority

Event subprocess has a priority over the error boundary event. So, when an error occurs, the subprocess starts, but the boundary error handler never be activated.

image::bpmn-events/start-error-event-example-2.png[,500]


==== Error Propagation

Suppose, the process has parallel paths with call activities, each of them may throw an error. Then, it's possible to use error boundary events without outgoing flows if there is an event subprocess for handling errors:

image::bpmn-events/parallel-errors catcing.png[,500]

The error, thrown inside call activity will be propagated to the top-level process and caught by event subprocess.


//todo -- непонятно у Флоубл
// Such an error will propagate its parent scopes upwards until a scope is found on which a boundary error event is defined that matches the error event definition.


==== Matching Errors

Usually, error event has a code. Sometimes the code can be omitted, then `id` parameter will be used.

*Single error catching event*

When there is only one error catching event in the given scope, it catches *ALL* errors with any codes.

In the example below, the single error catching event catches both errors with codes 1 and 2. If in the error catching event set parameter _Error_, it will be ignored.

image::bpmn-events/error-one-catch-many.png[,600]

An event subprocess with error start event works the same way -- it will catch any error.

*Matched errors codes*

In the other example, we can see designated error catching events for every type of errors:

image::bpmn-events/matching-errors.png[,600]

Respectively, if error #1 occurs, the first catching evens will be activated, if error #2 -- the second one.

[NOTE]
====
The BPM engine considers the error events matching when they refer to the same _error definition_.
====

*Error code doesn't match*

When a code of thrown error doesn't match any error catching event, the first defined error will be activated.

image::bpmn-events/error-code-not-match.png[,600]

The *first* means here which of boundary events is higher in the XML file:

[source,xml]
----
...
    <boundaryEvent id="Event_02" name="Catch error 2"
        attachedToRef="Activity_13z00xo"> <1>
      <outgoing>Flow_06d3rwf</outgoing>
      <errorEventDefinition id="ErrorEventDefinition_0w90u2d" />
    </boundaryEvent>
    <sequenceFlow id="Flow_1b1df9j" sourceRef="Event_01" targetRef="Activity_0tcie7m" />
    <sequenceFlow id="Flow_1trubue" sourceRef="Activity_0tcie7m" targetRef="Event_1073oeg" />
    <boundaryEvent id="Event_01" name="Catch error 1"
        attachedToRef="Activity_13z00xo"> <2>
      <outgoing>Flow_1b1df9j</outgoing>
      <errorEventDefinition id="ErrorEventDefinition_1aum1e6" />
    </boundaryEvent>
...
----
<1> -- Boundary event #2 defined first
<2> -- Boundary event #1 defined second

So, in our case, catching event #2 will be activated when the code of thrown error is "500".

[NOTE]
====
The same is applicable to boundary events attached to task or call activity.
====

*Errors without code*

The parameter `errorCode` can be omitted. In this case, `errorId` will be used instead.

For example, thrown error has a code "green":

[source,xml]
----
  <error id="err_green" name="Error green" errorCode="green" />
----

But catching event set to the error with id = "green" and without code:

[source,xml]
----
  <error id="green" name="Err1"/>
----

Those errors will be matched.

*Errors thrown programmatically*

When the error is generated programmatically, it has only code but not id:

[source,java]
----
throw new BpmnError("500");
----


[[unhandled-errors]]
=== Unhandled errors

When an error is thrown and not caught, a Flowable exception will be thrown.

// image::bpmn-events/multi-errors-example.png[,600]


[[expressions]]
== Expressions


[[markers]]
== Markers

A _marker_ refers to specific symbols or indicators used within the graphical representation of a process to convey additional information about the activities or events.

Markers are visual elements that provide quick insights into the behavior or characteristics of a process element. They help to differentiate between various types of activities, events, or gateways.

Types of markers:

* *Subprocess Marker*: A plus sign (+) in the upper left corner of a rounded rectangle indicates that the activity is a subprocess that can be expanded to show its internal details.

* *Event Markers*: Different symbols within circles can indicate the type of event (e.g., message, timer, error) and whether it is a catching or throwing event.

* *Multi-instance markers*: Three short vertical or horizontal lines indicating that an activity (task or subprocess) can be executed multiple times in parallel or sequentially.



[[participants]]
== Participants


[[process-definition]]
== Process Definitions

[[process-instance]]
== Process Instances


[[subscriptions]]
== Subscriptions

[[message-subscription]]
=== Message subscription

[[signal-subscription]]
=== Signal subscription


[[tokens]]
== Tokens


[[waiting-state]]
== Waiting State