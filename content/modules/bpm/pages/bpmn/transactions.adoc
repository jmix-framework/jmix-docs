= Transactions

Processes in BPMN can last quite a long time and include a lot of activities.

The BPM engine executes processes in a transactional manner. It means when you trigger an action such as starting a process, completing a task, or signaling an execution, the engine advances through the process until it encounters wait states on all active execution paths.



image::transactions/transaction-1.png[,600]

Flowable executes processes in a transactional manner, which can be customized to meet your specific needs. Let's explore how Flowable typically manages transactions. When you trigger an action in Flowable—such as starting a process, completing a task, or signaling an execution—the engine advances through the process until it encounters wait states on all active execution paths.

In more concrete terms, Flowable performs a depth-first search through the process graph and will return once it has reached wait states on every branch of execution. A wait state refers to a task that is scheduled to be performed later, meaning Flowable saves the current execution state and pauses until it is triggered again. This trigger can originate from an external source, such as a user task or a message reception task, or it can come from Flowable itself, for example, when a timer event occurs.

[[waiting-states]]
== Waiting States
In BPMN (Business Process Model and Notation), a waiting state refers to a point in the process where the execution is paused, and the process is waiting for an event or a trigger to continue. This state can occur due to various reasons, such as waiting for a message, a timer event, or user input.

[[fail-retry]]
== Fail Retry

In BPMN, the concept of *fail retry* refers to the mechanisms implemented to handle failures in service tasks. When a task fails due to an error, the BPMN engine can automatically retry the execution of that task based on predefined configurations.
There are two parameters:

* Number of retries
* Delay between retries

If the task returns BPMN error, Job Executor waits a specified time and tries to execute the task again.
If the maximum number of retries is reached and the task still fails, an incident is created, allowing for manual intervention or further error handling.

[IMPORTANT]
====
Fail retry is applicable to asynchronous tasks only.
====

[NOTE]
====
For synchronous service tasks, retries are not automatically handled by the process engine.
If a synchronous task fails, it will throw an exception and stop the process instance.
====




[[asynchronous-continuation]]
== Asynchronous Continuation



This segment of a BPMN process includes a user task, a service task, and a timer event.
The completion of the user task and the validation of the address are part of the same unit of work, meaning they should either succeed or fail together.
If the service task encounters an exception, we want to roll back the current transaction so that the execution returns to the user task, leaving it intact in the database.
This rollback behavior is the default in Flowable.

In step (1), an application or client thread completes the user task.
In that same thread, Flowable executes the service task and continues until it reaches a waiting state, which in this case is timer event (2).
At this point, Flowable returns control to the caller (3), potentially committing the transaction if it was initiated by Flowable.
This version maintains the original meaning while enhancing clarity and readability.



== Sidetrack: transactionality

In Flowable, database transactions play a crucial role to guarantee data consistency and solve concurrency problems. When you make a Flowable API call, by default, everything is synchronous and part of the same transaction. Meaning, when the method call returns, a transaction will be started and committed.

When a process instance is started, there will be one database transaction from the start of the process instance to the next wait state. In this example, this is the first user task. When the engine reaches this user task, the state is persisted to the database and the transaction is committed and the API call returns.

In Flowable, when continuing a process instance, there will always be one database transaction going from the previous wait state to the next wait state. Once persisted, the data can be in the database for a long time, even years if it has to be, until an API call is executed that takes the process instance further. Note that no computing or memory resources are consumed when the process instance is in such a wait state, waiting for the next API call.

In the example here, when the first user task is completed, one database transaction will be used to go from the user task through the exclusive gateway (the automatic logic) until the second user task. Or straight to the end with the other path.