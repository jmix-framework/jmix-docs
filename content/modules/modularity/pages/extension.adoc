= Расширение функциональности

Функциональность подсистем и дополнений фреймворка может быть расширена и изменена приложением или другими дополнениями, расположенными ниже по xref:creating-add-ons.adoc#hierarchy[иерархии].

Для декларативно созданных элементов, таких как сущности модели данных и XML-компоновки экранов UI, Jmix предлагает собственный механизм расширения. Бизнес-логика, определяемая бинами Spring, может быть расширена с использованием стандартных функций Java и Spring.

[[data-model]]
== Расширение модели данных

Рассмотрим пример расширения модели данных дополнения.

Предположим, у нас есть следующие сущности, определенные в дополнении `base`:

image::extension-diagram.svg[align="center"]

Их исходный код:

[source,java,indent=0]
----
include::example$/base/base/src/main/java/modularity/sample/base/entity/Department.java[tags=entity]
----

[source,java,indent=0]
----
include::example$/base/base/src/main/java/modularity/sample/base/entity/Employee.java[tags=entity]
----

В приложении `ext`, которое использует дополнение `base`, нам нужно добавить атрибуты `description` и `manager` к сущности `Department`. Очевидно, что мы не можем изменить исходный код дополнения, поэтому нам нужно определить в приложении другую сущность и сделать так, чтобы другие сущности ссылались на нее вместо `Department`:

image::extension-diagram-2.svg[align="center"]

Исходный код расширенной сущности:

[source,java,indent=0]
----
include::example$/ext/src/main/java/modularity/sample/ext/entity/ExtDepartment.java[tags=entity]
----
<1> В аннотации `@ReplaceEntity` указано, что эта сущность должна полностью заменить родительскую сущность, указанную в значении аннотации. Studio добавляет эту аннотацию, если вы установите флажок *Replace parent* в дизайнере сущностей.
<2> Стандартное наследование сущностей JPA. В данном случае базовый класс не определяет стратегию наследования JPA, поэтому атрибуты расширения будут храниться в той же таблице `BASE_DEPARTMENT`.
<3> Атрибуты, добавленные расширением.

После введения сущности `ExtDepartment` с аннотацией `@ReplaceEntity` в проект приложения, она будет возвращаться вместо сущности `Department` повсеместно в коде доступа к данным. Например, вы можете безопасно приводить ссылки к `ExtDepartment` классу:

[source,java,indent=0]
----
include::example$/ext/src/test/java/modularity/sample/ext/ExtApplicationTests.java[tags=ext-ref]
----

Кроме того, мета-класс сущности `ExtDepartment` будет возвращаться xref:data-model:metadata.adoc[метаданными API] для обоих классов Java `ExtDepartment` и `Department`. Исходный мета-класс сущности можно получить с помощью бина `ExtendedEntities`.

[[ui]]
== Расширение UI

Если вы замените сущность дополнения расширенной версией, скорее всего, вам также потребуется переопределить экраны пользовательского интерфейса этой сущности для отображения расширенных атрибутов. Ниже мы рассмотрим пример переопределения экрана просмотра сущности `Department`, замененной на `ExtDepartment` как описано в <<data-model,предыдущем разделе>> .

Чтобы расширить и переопределить экран, предоставленный дополнением, выберите шаблон *Override an existing screen* в мастере создания экрана Studio. Studio создаст новые файлы XML-дескриптора и контроллера. XML-дескриптор будет содержать атрибут `extends`, ссылающийся на дескриптор базового экрана:

[source,xml,indent=0]
----
include::example$/ext/src/main/resources/modularity/sample/ext/screen/department/ext-department-browse.xml[tags=extends]
----

После этого можно добавить компоненты для отображения расширенных атрибутов:

[source,xml,indent=0]
----
include::example$/ext/src/main/resources/modularity/sample/ext/screen/department/ext-department-browse.xml[tags=extends;extends1]
----

Вам не нужно повторять все элементы и атрибуты базового экрана, требуется только измененная часть. Результирующий XML будет объединен из базовых и расширенных дескрипторов — подробнее об этом см. <<descriptor-extension,ниже>>.

В нашем случае один из расширенных атрибутов (`manager`) является ссылкой на другую сущность. Эта ссылка будет загружаться по запросу из-за автоматической xref:data-access:fetching.adoc#lazy-loading[ленивой загрузки], но вы можете включить ссылку на xref:data-access:fetching.adoc#fetch-plan[фетч-план] экрана, чтобы избежать возможной проблемы "запросов N+1":

[source,xml,indent=0]
----
include::example$/ext/src/main/resources/modularity/sample/ext/screen/department/ext-department-browse.xml[tags=extends;extends1;extends2]
----

Контроллер расширенного экрана будет унаследован от базового класса контроллера:

[source,java,indent=0]
----
include::example$/ext/src/main/java/modularity/sample/ext/screen/department/ExtDepartmentBrowse.java[tags=extend]
----

Обратите внимание, что аннотация `@UiController` имеет то же значение, что и на базовом экране. Это важно, потому что на самом деле нам нужно _переопределить_ базовый экран. А это означает, что расширенный экран в системе повсеместно будет использоваться вместо базового, как это делается для замененных сущностей.

Общедоступные и защищенные методы базового контроллера можно переопределить, чтобы при необходимости расширить логику экрана.

[[descriptor-extension]]
=== Правила расширения XML-дескрипторов

Расширение дескрипторов XML не учитывает семантику экрана и работает исключительно на уровне XML. Оно объединяет два файла XML в соответствии со следующими правилами:

. Если в расширяющем дескрипторе есть определенный элемент, соответствующий элемент будет искаться в родительском дескрипторе по следующему алгоритму:

.. Если переопределяющий элемент имеет атрибут `id`, будет найден соответствующий элемент с таким же `id`.

.. Если поиск успешен, найденный элемент переопределяется.

.. В противном случае фреймворк определяет, сколько элементов с указанным путем и именем содержится в родительском дескрипторе. Если есть только один элемент, он переопределяется.

.. Если поиск не дает результата и в родительском дескрипторе имеется ноль или более одного элемента с заданным путем и именем, добавляется новый элемент.

. Текст для переопределенного или добавленного элемента копируется из расширяющего элемента.

. Все атрибуты из расширяющего элемента копируются в переопределенный или добавленный элемент. Если имена атрибутов совпадают, значение берется из расширяющего элемента.

. По умолчанию новый элемент добавляется в конец списка соседних элементов. Для того чтобы добавить новый элемент в начало или с произвольным индексом, сделайте следующее:

.. Определите дополнительное пространство имен в расширяющем дескрипторе: `xmlns:ext="http://jmix.io/schema/ui/window-ext"`.

.. Добавьте атрибут `ext:index` с нужным индексом, например: `ext:index="0"` к расширяемому элементу.

[[beans]]
== Переопределение Spring Beans

Все подсистемы Jmix используют бины Spring по их типу, а не по имени бина. Следовательно, бины можно переопределить, просто предоставив альтернативные реализации того же или расширенного типа. Мы рекомендуем следовать этому соглашению в ваших дополнениях и приложениях.

Чтобы переопределить бин Spring, определенный в дополнении, создайте его подкласс (или реализуйте тот же интерфейс) и объявите бин этого нового типа в конфигурации Java, добавив аннотацию `@Primary` к новому бину.

Например, предположим, что в дополнении `base` есть следующий бин:

[source,java,indent=0]
----
include::example$/base/base/src/main/java/modularity/sample/base/app/DepartmentService.java[tags=class]
----

Его можно переопределить в приложении следующим образом:

. Создайте его подкласс в проекте приложения:
+
[source,java,indent=0]
----
include::example$/ext/src/main/java/modularity/sample/ext/app/ExtDepartmentService.java[tags=class]
----
Определите бин с аннотацией `@Primary` в основном классе приложения или в любом классе `@Configuration`:
+
[source,java,indent=0]
----
include::example$/ext/src/main/java/modularity/sample/ext/ExtApplication.java[tags=extension]
----

После этого контейнер Spring всегда будет возвращать `ExtDepartmentService` вместо `DepartmentService`, поэтому любой вызов метода `sayHello()` даже из дополнения `base` будет выводить сообщения "Hello from base" и "Hello from ext". Конечно, можно не вызывать `super()` в переопределяющих методах и, следовательно, полностью заменить унаследованное поведение.

В редком случае, когда вам нужно переопределить бин, у которого уже есть подкласс, отмеченный как `@Primary`, вы можете использовать свойство приложения xref:ROOT:app-properties.adoc#jmix.core.exclude-beans[jmix.core.exclude-beans] для удаления других первичных бинов из контейнера.

[[modules-api]]
== API-модули

Бин `JmixModules` позволяет получать информацию о модулях, используемых в вашем приложении: список всех модулей, последний модуль в списке (обычно это приложение), дескриптор модуля по идентификатору модуля. Метод `getPropertyValues()` возвращает список значений, определенных для свойства каждым модулем.

Бин `JmixModulesAwareBeanSelector` предназначен для выбора эффективной реализации некоторого интерфейса из заданного списка. Он возвращает бин, принадлежащий самому низкому модулю в иерархии. Например, если вы знаете, что несколько дополнений определяют свои собственные реализации интерфейса `AmountCalculator`, и вы хотите использовать тот, который определен в самом нижнем модуле иерархии, это можно сделать следующим образом:

[source,java,indent=0]
----
include::example$/ext/src/test/java/modularity/sample/ext/ExtApplicationTests.java[tags=bean-selector]
----