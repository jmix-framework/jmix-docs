= REST DataStore

Задача REST DataStore — предоставить простой способ интеграции приложений Jmix. В результате такой интеграции появляется возможность получать доступ к внешним сущностям из удалённого приложения Jmix через интерфейс xref:data-access:data-manager.adoc[DataManager] таким же образом, как к локальным сущностям JPA. Внешние сущности могут отображаться в пользовательском интерфейсе, обновляться и сохраняться обратно в удалённое приложение с использованием стандартной CRUD-функциональности, предоставляемой Jmix, без написания дополнительного кода.

Данный раздел предоставляет справочную информацию о дополнении REST DataStore. Для получения информации о том, как использовать его в различных сценариях, обратитесь к следующим руководствам:

* xref:integrated-apps-guide:index.adoc[]
* xref:separate-tiers-guide:index.adoc[]

В данном документе используются следующие термины:

* _Сервисное приложение_ — приложение Jmix, предоставляющее данные через xref:rest:index.adoc[универсальный REST API].
* _Клиентское приложение_ — приложение Jmix, получающее данные от Сервисного приложения с использованием REST DataStore.

Сервисное и клиентское приложения могут использовать разные версии Jmix.

[[installation]]
== Установка

Для автоматической установки через Jmix Marketplace следуйте инструкциям в разделе xref:ROOT:add-ons.adoc#installation[Дополнения].

Для ручной установки добавьте следующие зависимости в ваш `build.gradle`:

[source,groovy,indent=0]
----
include::example$/rest-ds-client/build.gradle[tags=dependencies]
----

[[configuration]]
== Конфигурация

Базовая конфигурация включает следующие шаги.

В проекте сервисного приложения:

* Добавьте дополнения xref:rest:index.adoc[REST API] и xref:authorization-server:index.adoc[Authorization Server].

* Настройте выдачу токенов с типом гранта xref:authorization-server:obtaining-tokens.adoc#client-credentials-grant[Client Credentials].

В проекте клиентского приложения:

* Добавьте дополнение REST DataStore, как описано <<installation,выше>>.

* Добавьте дополнительное хранилище данных с дескриптором `restds_RestDataStoreDescriptor`, например:
+
[source,properties]
----
include::example$rest-ds-client/src/main/resources/application.properties[tags=store]
----

* Укажите свойства подключения к сервису для данного хранилища данных по его имени, например:
+
[source,properties]
----
include::example$rest-ds-client/src/main/resources/application.properties[tags=connection]
----

Если вы хотите выполнять аутентификацию реальных пользователей в сервисном приложении, как продемонстрировано в руководстве xref:separate-tiers-guide:index.adoc[], настройте xref:authorization-server:obtaining-tokens.adoc#resource-owner-password-credentials-grant[Password Grant] в сервисном приложении и добавьте следующие свойства в клиентское приложение:

[source,properties]
----
include::example$rest-ds-client/src/main/resources/application.properties[tags=authenticator]
----

[[data-model]]
== Модель данных

Клиентское приложение должно содержать DTO-сущности, эквивалентные сущностям сервисного приложения. Для автоматического сопоставления атрибуты этих сущностей должны совпадать по имени и типу.

Набор атрибутов может различаться. Например, сервисная сущность может иметь больше атрибутов, чем клиентская. Атрибуты, отсутствующие в одной из сущностей, будут иметь значение null после передачи данных.

Клиентская DTO-сущность должна иметь аннотацию `@Store`, указывающую на дополнительное хранилище данных.

Пример определения сущности `Region` в сервисном и клиентском приложениях представлен ниже.

[source,java,indent=0]
.Сущность Region в сервисном приложении
----
include::example$rest-ds-service/src/main/java/com/company/serviceapp/entity/Region.java[tags=jpa-entity]
----

[source,java,indent=0]
.Сущность Region в клиентском приложении
----
include::example$rest-ds-client/src/main/java/com/company/clientapp/entity/Region.java[tags=restds-entity]
----

Если имя клиентской сущности отличается от сервисного, используйте аннотацию `@RestDataStoreEntity` для явного указания имени сущности в сервисе. Например:

[source,java,indent=0]
----
include::example$rest-ds-client/src/main/java/com/company/clientapp/entity/RegionDto.java[tags=restds-entity]
----

Для вложенных атрибутов на стороне клиента используйте аннотацию `@JmixEmbedded` вместо `@Embedded` из JPA.

Для атрибутов композиции с типом один-ко-многим на стороне клиента определите атрибут `inverse` в аннотации `@Composition`.

Пример:

[source,java,indent=0]
----
include::example$rest-ds-client/src/main/java/com/company/clientapp/entity/Customer.java[tags=restds-entity]
----

[[fetch-plans]]
== Фетч-планы

При загрузке внешней сущности в клиентском приложении можно указать фетч-план для загрузки ссылок. В настоящий момент универсальный REST API xref:rest:entities-api/load-entities.adoc#fetch-plans[поддерживает] только именованные фетч-планы, определённые в xref:data-access:fetching.adoc#creating-fetch-plans[репозитории фетч-планов]. Таким образом, REST DataStore запрашивает данные из сервиса, предоставляя имя фетч-плана.

Поэтому и сервисное, и клиентское приложения должны определять все фетч-планы в своих репозиториях с соответствующими именами. Фетч-планы, встроенные в XML-дескрипторы, а также программно создаваемые на Java фетч-планы не поддерживаются.

[[loaded-state]]
== Загруженное состояние

Если фетч-план не включает какой-либо атрибут, этот атрибут не загружается. В отличие от атрибутов сущностей JPA, атрибуты REST-сущностей, которые не были загружены, имеют значение null и не вызывают исключений при доступе к ним.

При обновлении сущности REST DataStore сохраняет только загруженные атрибуты. Если атрибут не был загружен из сервиса, но впоследствии изменён с null на какое-либо значение, он считается загруженным, и новое значение будет сохранено.

Метод `EntityStates.isLoaded(entity, property)` корректно возвращает информацию о том, загружен ли определённый атрибут REST-сущности.

[[filtering-loaded-data]]
== Фильтрация загружаемых данных

Данный подраздел описывает параметры фильтрации, поддерживаемые при загрузке внешних сущностей с помощью `DataManager`. Все эти опции приводят к вызову xref:rest:entities-api/load-entities.adoc#load-list-search-filter[эндпойнта поиска] REST API сервисного приложения, поэтому по сети передаются только найденные сущности.

[[filter-by-conditions]]
=== По условиям

Пример:

[source,java,indent=0]
----
include::example$rest-ds-client/src/main/java/com/company/clientapp/DataLoadingSamples.java[tags=by-condition]
----

[[filter-by-query]]
=== По запросу

Запрос представляет собой выражение на JSON, поддерживаемое универсальным REST API в xref:rest:entities-api/load-entities.adoc#load-list-search-filter[эндпойнте поиска]:

[source]
----
include::example$rest-ds-client/src/main/java/com/company/clientapp/DataLoadingSamples.java[tags=by-query]
----

[[filter-by-identifiers]]
=== По идентификаторам

Пример:

[source,java,indent=0]
----
include::example$rest-ds-client/src/main/java/com/company/clientapp/DataLoadingSamples.java[tags=by-ids]
----

[[using-query-in-view-xml]]
=== Использование запроса в XML экранов

JSON-запрос может быть указан в XML-дескрипторах экранов для контейнеров данных и элементов `itemsQuery`:

[source,xml,indent=0]
----
include::example$rest-ds-client/src/main/resources/com/company/clientapp/view/customer/customer-detail-view.xml[tags=items-query]
----

Чтобы указать параметр вместо фиксированного значения в JSON-условиях запроса, используйте ключ `parameterName` вместо `value`, как показано выше. REST DataStore заменит это свойство на `"value": <parameter-value>` в результирующем запросе.

Также можно использовать фасет xref:flow-ui:facets/dataLoadCoordinator.adoc[], но только с ручной конфигурацией. В следующем примере контейнеры данных `regionsDc` и `customersDc` связаны, используя JSON-запрос и `dataLoadCoordinator`, для предоставления в режиме мастер-деталь списка регионов и клиентов для выбранного региона:

[source,xml,indent=0]
----
include::example$rest-ds-client/src/main/resources/com/company/clientapp/view/region/region-list-view.xml[tags=query]
----

[[entity-events]]
== События сущностей

REST DataStore отправляет xref:data-access:entity-events.adoc#saving-loading-events[события EntitySavingEvent и EntityLoadingEvent] так же, как `JpaDataStore`. Однако оно не отправляет xref:data-access:entity-events.adoc#entity-changed-event[событие EntityChangedEvent], так как не может предоставить информацию об изменённых с момента загрузки атрибутах. Вместо события `EntityChangedEvent` REST DataStore отправляет два специфических события:

* `RestEntitySavedEvent` — отправляется после успешного сохранения сущности в сервисе. Оно содержит сохранённый экземпляр сущности в состоянии перед отправкой в сервис.
* `RestEntityRemovedEvent` — отправляется после удаления сущности из сервиса. Оно содержит удалённую сущность в состоянии перед отправкой в сервис.

[[security]]
== Безопасность

REST DataStore применяет xref:security:resource-roles.adoc#entity-policy[политику операций над сущностями], определённую ресурсными ролями, и xref:security:row-level-roles.adoc#predicate-policy[политику предикатов], определённую ролями уровня строк.

Аутентификация в REST DataStore может выполняться с использованием Client Credentials Grant или Password Grant, предоставляемых дополнением Authorization Server. Последний вариант требует настройки дополнительных свойств `<ds-name>.authenticator` и `jmix.restds.authentication-provider-store`, как описано в разделе <<configuration>>.

[[invoking-services]]
== Вызов сервисов

Бин `RestDataStoreUtils` предоставляет ссылку на Spring `RestClient` для конкретного REST DataStore. Он позволяет вызывать произвольные эндпойнты сервисного приложения, используя параметры подключения и аутентификации, настроенные для REST DataStore.

Пример вызова метода бизнес-сервиса приведён в руководстве xref:integrated-apps-guide:index.adoc[].

[[limitations]]
== Ограничения

REST DataStore имеет следующие ограничения по сравнению с хранилищем данных JPA:

* Не поддерживает ленивую загрузку ссылок. Ссылки, которые не были загружены по фетч-плану, остаются null при доступе.

* Отсутствует событие `EntityChangeEvent` с `AttributeChanges`.

* Методы `DataManager.loadValues()` и `loadValue()` не реализованы и выбрасывают `UnsupportedOperationException`.