= Entities

There are the following types of entities in Jmix:

* <<jpa,JPA entities>> are Java objects stored in a database using https://en.wikibooks.org/wiki/Java_Persistence[Java Persistence API^].

* <<dto,DTO entities>> are simple Java objects that are not tied to any specific persistence technology.

* <<key-value,Key-Value Entity>> is a dynamic entity with an arbitrary number of attributes.

Entities are characterized by their <<attributes,attributes>>.

JPA and DTO entities are defined by Java classes and have some <<jmix-annotations,annotations specific to Jmix>>.

TIP: Use xref:studio:entity-designer.adoc[Studio entity designer] to create JPA and DTO entities.

[CAUTION]
====
Do not implement `equals()` and `hashCode()` methods in your entity classes explicitly or by using annotation processors. These methods are xref:concepts:features.adoc#entity-enhancement[generated automatically] by Jmix at build time and use entity identifiers for comparison.

In particular, never add `@EqualsAndHashCode` and `@Data` Lombok annotations  to entity classes.
====

[[jpa]]
== JPA Entities

JPA entity is a Java class annotated according to JPA rules. JPA entities are stored in a relational database connected as a main or additional xref:data-stores.adoc[data store].

JPA annotations define mapping between database table fields and entity attributes. Jmix imposes the following restrictions on mapping annotations:

* Attribute annotations must be placed only on fields (`AccessType.FIELD`).
* Not supported: `@IdClass`, `@ElementCollection`.

Below is an example of a typical JPA entity class:

.Customer.java
[source,java,indent=0]
----
include::example$/data-model-ex1/src/main/java/com/company/demo/entity/Customer.java[tags=entity]
----

<1> Mandatory <<jmix-entity,@JmixEntity>> annotation.
<2> `@jakarta.persistence.Table` annotation specifies the database table name.
<3> `@jakarta.persistence.Entity` annotation indicates that the class is a JPA entity.
<4> The <<jmix-generated-value,@JmixGeneratedValue>> annotation indicates that the primary key must be generated and assigned by Jmix when creating entity instance in memory.
<5> `@jakarta.persistence.Id` annotation indicates the primary key.
<6> `@jakarta.persistence.Column` annotation specifies a mapping to a table column. The `nullable = false` parameter indicates that the xref:db-migration.adoc[database migration] mechanism should create the column with the `NOT NULL` constraint.
<7> `@jakarta.persistence.Version` indicates that the entity must be optimistically locked using the value of this attribute. The attribute should be of `Integer` type. Studio creates such an attribute automatically if you select the _Versioned_ trait for the entity.
<8> The <<instance-name,@InstanceName>> annotation here indicates a single attribute chosen as the instance name.
<9> `@NotNull` and `@Email` annotations from the `javax.validation.constraints` package are the examples of using https://beanvalidation.org[Bean Validation^] annotations in entities.
<10> The `unique = true` parameter of the `@Column` annotation indicates that the database migration mechanism should add the unique constraint to the column.

Both table and entity name can have a prefix to eliminate name conflicts with entities of other modules. Studio inserts this prefix if the project has the `jmix.projectId` property in `build.gradle`.

[[traits]]
=== Traits

A trait is a set of attributes that gives the entity some specific system-level behavior. These attributes are handled by the framework and are not intended to be edited by users or your application code.

Studio entity designer helps you assign available traits to an entity. You can also do it manually by creating corresponding attributes and annotating them as described below.

[[has-uuid-trait]]
=== Has UUID Trait

The _Has UUID_ trait provides a globally unique identifier, assigned automatically when an instance is created in memory. The trait is implemented by an attribute of the `UUID` type annotated with <<jmix-generated-value>>.

TIP: When creating an entity in Studio, the Has UUID trait is selected automatically if you choose UUID in *Id type*. Add the Has UUID trait if you choose a different type and *Id value* different from *Generated by Jmix*.

This trait does not require an additional attribute if you choose `UUID` type for the entity identifier.

Adding the Has UUID trait is highly recommended if you use an identifier attribute whose value is not assigned right at the creation of entity instance in memory. This is the case for `Long` or `Integer` identifiers mapped to an identity column, and for identifiers of any type assigned by users. If such an entity has no `@JmixGeneratedValue` attribute, its `hashCode()` method always returns a constant value, which affects the performance of collections based on hash tables.

[[versioned-trait]]
=== Versioned Trait

The _Versioned_ trait provides optimistic locking on the JPA level. It is implemented by an integer attribute annotated with `@Version`.

WARNING: Never change the value of the `@Version` attribute in the application code. It will lead to the inability to update the instance in the database.

[[audit-traits]]
=== Audit Traits

The _Audit of creation_ and _Audit of modification_ traits provide tracking of who and when created and modified an entity instance. They are implemented by attributes of appropriate types annotated with `@CreatedBy`, `@CreatedDate`, `@LastModifiedBy`, `@LastModifiedDate` annotations from the Spring Data project.

For example:

[source,java,indent=0]
----
include::example$/data-model-ex1/src/main/java/com/company/demo/entity/Order.java[tags=audit-traits]
----

Audit attributes are assigned automatically when the framework saves entity instances.

[[soft-delete-trait]]
=== Soft Delete Trait

The _Soft Delete_ trait provides soft deletion of entity instances. It is implemented by a pair of attributes annotated with `@DeletedDate` and `@DeletedBy`, for example:

[source,java,indent=0]
----
include::example$/data-model-ex1/src/main/java/com/company/demo/entity/Order.java[tags=soft-delete-trait]
----

See more information in the xref:soft-deletion.adoc[] section.

[[inheritance]]
=== Entity Inheritance

Jmix framework uses principles of JPA inheritance. Studio entity designer automatically generates the necessary annotations in accordance with the chosen inheritance strategy. The main annotations are listed below.

[[discriminator-column-annotation]]
==== @DiscriminatorColumn

Is used for defining a database column responsible for the distinction of entity types in the cases of `SINGLE_TABLE` and `JOINED` inheritance strategies.

Parameters:

* `name` - the discriminator column name.
* `discriminatorType` - the discriminator column type.
* `length` - the column length for String-based discriminator types.

Example:

[source,java,indent=0]
----
@DiscriminatorColumn(name = "TYPE", discriminatorType = DiscriminatorType.INTEGER)
----

[[discriminator-value-annotation]]
==== @DiscriminatorValue

Defines the discriminator column value for this entity.

Example:

[source,java,indent=0]
----
@DiscriminatorValue("0")
----

[[inheritance-annotation]]
==== @Inheritance

Defines the inheritance strategy to be used for an entity class hierarchy. It is specified on the entity class that is the root of the entity class hierarchy.

Parameters:

* `strategy` - the inheritance strategy, `SINGLE_TABLE` by default.

[[mapped-superclass]]
==== @MappedSuperclass

Defines that the class is an ancestor for some entities, and its attributes must be used as part of descendant entities. Such a class is not associated with any particular database table.

[[primary-key-join-column]]
==== @PrimaryKeyJoinColumn

Is used in the case of `JOINED` inheritance strategy to specify a foreign key column for the entity, which refers to the primary key of the ancestor entity.

Parameters:

* `name` - the name of the foreign key column of the entity.
* `referencedColumnName` - the name of a primary key column of the ancestor entity

Example:

[source,java,indent=0]
----
@PrimaryKeyJoinColumn(name = "CARD_ID", referencedColumnName = "ID")
----

[[dto]]
== DTO Entities

The data model of your application can contain entities that exist only in memory or are mapped to some external data using mechanisms different from JPA. We call such entities _DTO_ because they are often used as Data Transfer Objects in parameters and return values in xref:rest:index.adoc[] and when communicating with external APIs.

A DTO entity can be as simple as that:

.OperationResult.java
[source,java,indent=0]
----
include::example$/data-model-ex1/src/main/java/com/company/demo/entity/OperationResult.java[tags=entity]
----

<1> Mandatory <<jmix-entity,@JmixEntity>> annotation.
<2> All object properties (fields with accessor methods) become entity attributes.

Entity attributes can have annotations to specify some details about them:

.ProductPart.java
[source,java,indent=0]
----
include::example$/data-model-ex1/src/main/java/com/company/demo/entity/ProductPart.java[tags=entity]
----

<1> The <<jmix-entity,@JmixEntity>> annotation defines the entity name explicitly.
<2> The <<jmix-property,@JmixProperty>> annotation with `mandatory = true` parameter indicates that the attribute is required, i.e. it must contain a value.
<3> The <<instance-name,@InstanceName>> annotation here indicates a single attribute chosen as the instance name.
<4> An attribute without annotations.

DTO entities can be associated with a xref:data-stores.adoc#custom[custom data store] for generic CRUD operations via `DataManager` and automatic resolving of references to the DTO entity from JPA entities.

In the example below, you can also see how to exclude some object properties from being entity attributes (more on this in the <<attributes>> section):

.Metric.java
[source,java,indent=0]
----
include::example$/data-model-ex1/src/main/java/com/company/demo/entity/Metric.java[tags=entity]
----

<1> The `@Store` annotation specifies a custom data store.
<2> The `annotatedPropertiesOnly = true` parameter of <<jmix-entity,@JmixEntity>> annotation indicates that object properties not annotated with <<jmix-property,@JmixProperty>> will not be entity attributes.
<3> The <<jmix-property,@JmixProperty>> annotation with `mandatory = true` parameter indicates that the attribute is required, i.e. it must contain a value.
<4> The <<jmix-id,@JmixId>> annotation indicates that the attribute is the entity identifier.
<5> The <<jmix-generated-value,@JmixGeneratedValue>> annotation indicates that the identifier must be generated and assigned by Jmix when creating the entity instance in memory.
<6> The <<jmix-property,@JmixProperty>> annotation here just indicates that the property is an entity attribute.
<7> Not annotated property is not an entity attribute because of `annotatedPropertiesOnly = true` parameter of `@JmixEntity` annotation.

[[key-value]]
== Key-Value Entity

`KeyValueEntity` lets you represent arbitrary sets of named values as entities and hence work with data that is not directly represented by Java classes (JPA or DTO entities).

Consider an example: you have `Order` entity in your data model, and you need to calculate sum of order amounts aggregated by customers and show this data in UI. Then you can execute a JPQL query and load the result list as a list of `KeyValueEntity` instances using `DataManager`:

[source,java,indent=0]
----
include::example$/data-model-ex1/src/test/java/com/company/demo/KeyValueTest.java[tags=load]
----

The returned `KeyValueEntity` instances will have two attributes which you specified in the `properties()` method: `customer` with the value of the first field in the query result set, and `total` with the value of the second field. You can get them as follows:

[source,java,indent=0]
----
include::example$/data-model-ex1/src/test/java/com/company/demo/KeyValueTest.java[tags=get-value]
----

Jmix UI has special xref:flow-ui:data/key-value-containers.adoc[key-value data containers] for binding UI components to `KeyValueEntity` instances.

[[attributes]]
== Entity Attributes

NOTE: There is another term for entity attributes: _entity properties_. It's often used in the Jmix codebase, for example in annotations: `@JmixProperty`, `@DependsOnProperties`, etc.

Each entity attribute should have an appropriate type. Jmix supports the following types out-of-the-box:

* `java.lang.String`
* `java.lang.Character`
* `java.lang.Boolean`
* `java.lang.Integer`
* `java.lang.Long`
* `java.lang.Double`
* `java.math.BigDecimal`
* `java.util.Date`
* `java.time.LocalDate`
* `java.time.LocalTime`
* `java.time.LocalDateTime`
* `java.time.OffsetTime`
* `java.time.OffsetDateTime`
* `java.sql.Date`
* `java.sql.Time`
* `java.util.UUID`
* `java.net.URI`
* `byte[]` (byte array)
* xref:enumerations.adoc[Enumeration]
* Entity or a collection of entities (a reference attribute)

You can use a type not from the list above if you create an appropriate xref:data-types.adoc[Datatype] implementation and make sure your type is supported by the underlying xref:data-stores.adoc[data store].

CAUTION: Note that Java primitive types (`int`, `boolean`, etc.) cannot be used for entity attributes.

In JPA and DTO entities, there are two types of attributes:

* _Field-based attribute_ corresponds to a field and a pair of accessor methods (getter / setter) of the field. The field name becomes the attribute name.
+
The setter can be omitted, then the attribute is read-only.
+
Example of a field-based attribute:
+
.User.java
[source,java,indent=0]
----
include::example$/data-model-ex1/src/main/java/com/company/demo/entity/User.java[tags=field-based-attr-1;field-based-attr-2]
----

* _Method-based attribute_ corresponds to a method without parameters, returning a supported type, and with a name starting from `get`, for example `getCustomer()`. The method name without `get` with the first letter in lower case becomes the attribute name: `getFullName()` -> `fullName`.
+
Example of a method-based attribute:
+
.User.java
[source,java,indent=0]
----
include::example$/data-model-ex1/src/main/java/com/company/demo/entity/User.java[tags=method-based-attr]
----

An entity class can have properties (field + getter/setter) and methods that are not entitiy attributes, that is not included in metadata. So you can use such properties and methods in your application code, but the framework will not recognize them and will not display them in UI or transfer through the REST API.

Whether a property or a qualifying method becomes an entity attribute is subject to the following rules:

* If the `annotatedPropertiesOnly` parameter of <<jmix-entity,@JmixEntity>> annotation is `false` (which is the default), the following object properties become entity attributes:
+
--
* For JPA entities: all properties except annotated with `@jakarta.persistence.Transient`.
* For DTO entities: all properties.
* For both: all properties and methods annotated with <<jmix-property,@JmixProperty>>.
--

* If the `annotatedPropertiesOnly` parameter is set to `true`, only the properties and methods annotated with <<jmix-property,@JmixProperty>> become entity attributes.

[[references]]
== References

Reference attributes define relationships between entities. References can be single-value (to-one relationships) or collections (to-many relationships).

By default, a relationship is an _association_, which means that both entities can exist independently of each other, without any ownership. For example, in a Customer - Order relationship, Order has an attribute which is a reference to Customer. Users create customers and orders independently, select a customer for an order, and change the reference to another customer if needed.

Jmix also supports a stronger connection between entities called _composition_. Composition implies ownership, when an entity instance can exist only as a part of its owning entity instance. For example, in a Order - OrderLine relationship, Order has an attribute which is a collection of OrderLine instances. Each OrderLine instance is created for a particular Order and becomes its part, it cannot belong to another Order.

Entities belonging to a composition are edited together in UI. For example, a user opens an Order edit screen and can create and edit OrderLines in their separate edit screens, but all changes both for the Order and all its OrderLines are saved to the database together in one transaction, and only after the user confirms saving of the owning entity - Order.

For a more detailed understanding of compositions, refer to the xref:data-modeling-composition-guide:index.adoc[] guide.

Composition relationship is specified by the <<composition,@Composition>> annotation on the reference attribute.

TIP: Studio entity designer allows you to select a relationship type in the *Attribute type* field.

[[cross-data-store-ref]]
== Cross-Datastore References

`DataManager` can automatically maintain To-One references between entities from different xref:data-stores.adoc[data stores], if they are properly defined.

TIP: Studio entity designer automatically defines the set of attributes for cross-datastore references when you select an entity from a different data store as an association.

Let's take an example: you have `Customer` entity in the main data store and `Address` entity in an additional data store, and you want to have a reference from `Customer` to `Address`. Then `Customer` entity should contain the following two attributes:

[source,java,indent=0]
----
include::example$/data-model-ex1/src/main/java/com/company/demo/entity/Customer.java[tags=cross-datastore-ref]
----

<1> The `addressId` attribute stores the identifier of `Address`. This attribute is annotated with `@SystemLevel` to indicate to the framework that the attribute should not be displayed to users.
<2> The `address` attribute contains the reference to the `Address` entity. This attribute is transient (not stored in the database) and annotated with <<depends-on-properties,@DependsOnProperties>> to indicate to the framework that the attribute value depends on another attribute.

After that, when you load `Customer` with a fetch plan including `address` attribute, `DataManager` automatically loads related `Address` from the additional data store. The framework optimizes loading of collections for performance: after loading a list of customers, it loads references from the additional data store in batches. The size of the batch is defined by the xref:ROOT:app-properties.adoc#jmix.core.cross-data-store-reference-loading-batch-size[jmix.core.cross-data-store-reference-loading-batch-size] application property.

When you save an entity graph which includes `Customer` with `Address`, `DataManager` saves the instances via corresponding `DataStore` implementations, and then saves the identifier of the address in the customer’s `addressId` attribute.

[[instantiation]]
== Instantiating Entities

When creating instances of JPA and DTO entities, use the appropriate framework interface instead of invoking the class constructor with the `new` operator. Only in this case the framework can initialize fields annotated with <<jmix-generated-value,@JmixGeneratedValue>> and invoke <<post-construct,@PostConstruct>> methods.

The most common core method for instantiating entities is `Metadata.create()`:

[source,java,indent=0]
----
include::example$/data-model-ex1/src/main/java/com/company/demo/bean/OrderService.java[tags=metadata-create]
----

If you write business logic and already have xref:data-access:data-manager.adoc[DataManager] in your code, use its `create()` method, which just saves you from additionally injecting the `Metadata` bean. For example:

[source,java,indent=0]
----
include::example$/data-model-ex1/src/main/java/com/company/demo/bean/OrderService.java[tags=data-manager-create]
----

In a UI view, you can use either of two methods described above. But you may also want the created instance to be saved automatically by xref:flow-ui:data/data-context.adoc[DataContext] of the view. Then use the `DataContext.create()` method which creates an instance and immediately merges it to start tracking its changes. In the example below, we create an instance of `ProductPart` entity, merge it into `DataContext` and add to a data container to display in a UI table:

[source,java,indent=0]
----
include::example$/data-model-ex1/src/main/java/com/company/demo/view/product/ProductDetailView.java[tags=data-context-create]
----

[[uniqueness]]
== Uniqueness

Jmix relies on database unique constraints for maintaining uniqueness of entity instances. So if you want to make an entity attribute or a set of attributes unique, you should create an appropriate index for the database table.

Studio xref:studio:entity-designer.adoc[] contains the *Indexes* tab where you can define unique indexes. The index definitions are stored in the `@Table` annotation of the entity and later used by Liquibase changelog generator for creating indexes in the database schema.

NOTE: The `unique = true` attribute of the `@Column` annotation is not interpreted by Jmix in any way.

// todo flowui
// See xref:ui:exception-handlers/unique-constraint-violation-exception.adoc[] section for how to customize messages displayed by the framework for unique constraint violation errors.

If you want to define a unique attribute for an entity with the Soft Delete trait, refer to the xref:data-model:soft-deletion.adoc#unique-constraints[Soft Deletion] section.

[[jmix-annotations]]
== Jmix Entity Annotations

Jmix entity annotations are described below in alphabetical order.

NOTE: Jmix entities can also have annotations for JPA mappings, <<audit-traits,audit traits>> and xref:soft-deletion.adoc[soft deletion].

[[comment]]
=== @Comment

`@Comment` annotation is used to provide a description for data model entities and their attributes, for example:

[source,java,indent=0]
----
include::example$/data-model-ex1/src/main/java/com/company/demo/entity/Location.java[tags=comment]
----

For all databases except HSQL, Studio generates `setTableRemarks` and `setColumnRemarks` Liquibase changelog operations to store the comments in the database schema. So the comments become available through any database inspection tool.

You can also extract comments from metadata (or directly from class annotations) to display in the application UI or generate a documentation. Use `MetadataTools.getMetaAnnotationValue()` methods for convenience.

TIP: Studio supports creating comments in the xref:studio:entity-designer.adoc[Entity Designer]. See the *Comment* edit links in the lists of entity and attribute parameters. When a comment is set, the link shows its first few words.

[[composition]]
=== @Composition

`@Composition` annotation on a reference attribute indicates that the relationship is a <<references,composition>>.
For example:

[source,java,indent=0]
----
include::example$/data-model-ex1/src/main/java/com/company/demo/entity/Order.java[tags=composition]
----

[[db-view]]
=== @DbView

`@DbView` annotation indicates whether a JPA entity is mapped to a database view. Database migration scripts are not generated for such entities.

[[ddl-generation]]
=== @DdlGeneration

`@DdlGeneration` annotation defines whether development tools should generate DDL scripts for this entity.

The scripts generation mode is set with the `DbScriptGenerationMode` enumeration:

* `CREATE_AND_DROP` - full generation of initialization and update scripts;
* `CREATE_ONLY` - full generation of initialization scripts. Update scripts are generated without statements to drop columns;
* `DISABLED` - initialization and update scripts are not generated.

Default value: `CREATE_AND_DROP`.

In addition, you can fine-tune the scripts generation using the following attributes:

* `unmappedColumns` - the list of columns that exist in the database but should not be mapped to the entity. Drop scripts for these columns will not be generated;
* `unmappedConstraints` - the list of constraints and indexes that exist in the database but should not be mapped to the entity. Drop scripts for these columns will not be generated.

[[depends-on-properties]]
=== @DependsOnProperties

`@DependsOnProperties` annotation specifies entity attributes that the annotated attribute depends on. These properties are taken into account when building fetch plans and when loading/saving references to entities from different data stores. Also, if the annotated property is read-only (without a setter), `EntityPropertyChangeEvent` is sent for this attribute when the specified attributes are changed.

You can specify only immediate local and reference properties. Property paths like `customer.name` are not supported.

[[instance-name]]
=== @InstanceName

_Instance name_ is a human-readable text that represents an entity instance. Think of it as of an application-level `toString()` method. It is used extensively in UI when displaying an entity instance in a single field or table cell. You can also get the instance name programmatically using the `MetadataTools.getInstanceName()` method.

The `@InstanceName` annotation can be present on a single field or a method of the object.

In the former case, the annotated attribute value is used as the instance name. For example:

[source,java,indent=0]
----
@InstanceName
@Column(name = "NAME")
private String name;
----

If you want to generate something more complex than a single attribute value, create a method returning `String` in the entity class. For example:

[source,java,indent=0]
----
include::example$/data-model-ex1/src/main/java/com/company/demo/entity/GeoPointEntity.java[tags=instance-name]
----

The method can accept any Spring beans as parameters. In the example above, the `Messages` bean is used to format the instance name according to the current user locale.

The <<depends-on-properties,@DependsOnProperties>> annotation on the instance name method is necessary, because it specifies attributes of the built-in `_instance_name` fetch plan.


[[jmix-entity]]
=== @JmixEntity

`@JmixEntity` is a mandatory annotation indicating that the class is a Jmix entity.

If the class has `@jakarta.persistence.Entity` annotation, the framework obtains entity name for the metadata from it, and `@JmixEntity` should not specify the `name` parameter. Otherwise, specify the entity name in the `name` parameter. If neither `@JmixEntity` nor `@jakarta.persistence.Entity` have `name` parameter, the entity name equals the Java class simple name.

The `annotatedPropertiesOnly` parameter specifies what object properties become entity attributes, see <<attributes>> for more details.

[[jmix-generated-value]]
=== @JmixGeneratedValue

`@JmixGeneratedValue` annotation indicates that the entity attribute value must be generated and assigned by the framework when creating entity instance in memory.

The annotated attribute must be of `Long`, `Integer` or `UUID` type, and the entity should not have more than one `UUID` attribute marked with this annotation.

CAUTION: Note that the `@JmixGeneratedValue` annotation doesn't take any effect if you create an entity instance using the `new` operator. See <<instantiation,instantiating entities>> for proper methods of creating new instances.

[[jmix-id]]
=== @JmixId

`@JmixId` annotation specifies an entity identifier for <<dto,DTO entities>>. You should explicitly choose an identifier if your DTO entity is mapped to some external data and you need to load/save its instances repeatedly, because in this case you need to maintain the object identity through the entity lifecycle.

You can use an existing attribute for an identifier if the attribute contains unique values, for example:

[source,java]
----
@JmixId
private String code;
----

If there is no such naturally unique attribute, define one and annotate it also with <<jmix-generated-value,@JmixGeneratedValue>> to assign a unique value on instance creation:

[source,java]
----
@JmixId
@JmixGeneratedValue
private UUID id;
----

[[jmix-property]]
=== @JmixProperty

`@JmixProperty` annotation indicates that an object field or method is an entity attribute. See <<attributes>> for more details.

Use the `mandatory` parameter if you want to specify that the attribute requires a value, and the object field has no JPA `@Column` annotation where you could set `nullable = false`.

[[number-format]]
=== @NumberFormat

Specifies a format for an attribute of the `Number` type (it can be `BigDecimal`, `Integer`, `Long`, or `Double`). Values of such attribute will be formatted and parsed throughout the UI according to the provided annotation parameters:

* `pattern` - the format pattern as described for https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/text/DecimalFormat.html[DecimalFormat^].

* `decimalSeparator` - the symbol to use for decimal separator (optional).

* `groupingSeparator` - the symbol to use for grouping (thousands) separator (optional).

NOTE: If `decimalSeparator` and/or `groupingSeparator` are not specified, their values are obtained from the xref:data-model:data-types.adoc#localized-format-strings[current user's locale] for locale-dependent formatting, or from server default locale for locale-independent formatting.

Examples:

[source,java,indent=0]
----
include::example$/data-model-ex1/src/main/java/com/company/demo/entity/Formatters.java[tags=number-format]
----

[[on-delete]]
=== @OnDelete

The `@OnDelete` annotation can be used on reference attributes of xref:soft-deletion.adoc[soft-deleted] entities. It specifies what should happen to the referenced entity when the entity instance containing the annotation (_this_ entity) is deleted.

The annotation can have one of the following values:

* `DeletePolicy.DENY` – to throw an exception on attempt to delete the entity if the reference is not null.

* `DeletePolicy.CASCADE` – to delete the referenced entities together with this entity.

* `DeletePolicy.UNLINK` – to disconnect the referenced entity by setting the reference attribute to null. Use this value only on the owning side of the relationship (the one with the `@JoinColumn` annotation).

[[on-delete-inverse]]
=== @OnDeleteInverse

The `@OnDelete` annotation can be used on reference attributes of xref:soft-deletion.adoc[soft-deleted] and regular hard-deleted entities. It specifies what should happen to the entity instance containing the annotation (_this_ entity) when the referenced entity is deleted.

The annotation can have one of the following values:

* `DeletePolicy.DENY` – to throw an exception on attempt to delete the referenced entity.

* `DeletePolicy.CASCADE` – to delete this entity together with the referenced entity.

* `DeletePolicy.UNLINK` – to set the reference attribute to null.

For soft-deleted entities, `@OnDeleteInverse` is handled by the framework at runtime. The `DENY` and `CASCADE` values can be used on both owning (the one with the `@JoinColumn` annotation) and non-owning (`mappedBy`) sides of the relationship. The `UNLINK` value should be used only on the owning side.

For regular hard-deleted entities, `@OnDeleteInverse` with `CASCADE` and `UNLINK` values is handled by Studio when generating Liquibase changelogs. It must be used only on the owning (the one with the `@JoinColumn` annotation) side of the relationship and leads to creating a foreign key constraint with the `ON DELETE CASCADE` or `ON DELETE SET NUll` parameters.

[[post-construct]]
=== @PostConstruct

Use `jakarta.annotation.PostConstruct` annotation on a method that performs initialization of a new entity instance. For example:

[source,java,indent=0]
----
include::example$/data-model-ex1/src/main/java/com/company/demo/entity/Customer.java[tags=post-construct]
----

The annotated method can accept any Spring beans. In the example below, we use `TimeSource` bean to initialize a `date` attribute:

[source,java,indent=0]
----
include::example$/data-model-ex1/src/main/java/com/company/demo/entity/Order.java[tags=post-construct]
----

CAUTION: Note that the `@PostConstruct` annotated method is not invoked if you create an entity instance using the `new` operator. See <<instantiation,instantiating entities>> for proper methods of creating new instances.

[[property-datatype]]
=== @PropertyDatatype

If you have multiple xref:data-types.adoc[datatypes] for a Java type of an entity attribute, `@PropertyDatatype` annotation lets you specify a `Datatype` implementation explicitly by its id. For example:

[source,java,indent=0]
----
include::example$/data-model-ex1/src/main/java/com/company/demo/entity/Model.java[tags=datatype]
----

[[store]]
=== @Store

Use `@Store` annotation on an entity class to associate the entity with an additional xref:data-stores.adoc[data store].

[[system-level]]
=== @SystemLevel

`@SystemLevel` annotation indicates that annotated entity or its attribute is low-level and should not be displayed in UI.
