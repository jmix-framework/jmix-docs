= Сущности

В Jmix существуют следующие типы сущностей:

* <<jpa,Сущности JPA>> – это объекты Java, хранящиеся в базе данных с использованием https://en.wikibooks.org/wiki/Java_Persistence[Java Persistence API^].

* <<dto,Сущности DTO>> – это простые объекты Java, которые не привязаны к какой-либо конкретной технологии персистентности.

* <<key-value,Сущность Key-Value>> (ключ-значение) – это динамическая сущность с произвольным количеством атрибутов.

Сущности характеризуются своими <<attributes,атрибутами>>.

Сущности JPA и DTO сущности определяются классами Java и имеют некоторые <<jmix-annotations,специфичные для Jmix аннотации>>.

TIP: Для создания сущностей JPA и DTO используйте xref:studio:entity-designer.adoc[дизайнер сущностей] Studio.

[CAUTION]
====
Не создавайте методы `equals()` и `hashCode()` в ваших классах сущностей явно или с помощью процессоров аннотаций. Эти методы будут xref:concepts:features.adoc#entity-enhancement[сгенерированы автоматически] фреймворком во время сборки приложения. Сгенерированные методы будут использовать идентификаторы сущностей для сравнения.

В частности, никогда не добавляйте аннотации `@EqualsAndHashCode` и `@Data` от Lombok к классам сущностей.
====

[[jpa]]
== Сущности JPA

JPA сущность – это класс Java, аннотированный в соответствии с правилами JPA. Сущности JPA хранятся в реляционной базе данных, подключенной в качестве основного или дополнительного xref:data-stores.adoc[хранилища данных].

Аннотации JPA определяют отображение между полями таблицы базы данных и атрибутами сущности. Jmix налагает следующие ограничения на аннотации JPA:

* Аннотации атрибутов должны размещаться только в полях (`AccessType.FIELD`).
* Не поддерживаются: `@IdClass`, `@ElementCollection`.

Ниже приведен пример типичного класса сущности JPA:

.Customer.java
[source,java,indent=0]
----
include::example$/data-model-ex1/src/main/java/com/company/demo/entity/Customer.java[tags=entity]
----

<1> Обязательная аннотация <<jmix-entity,@JmixEntity>>.
<2> Аннотация `@jakarta.persistence.Table` указывает имя таблицы базы данных.
<3> Аннотация `@jakarta.persistence.Entity` указывает, что класс – сущность JPA.
<4> Аннотация <<jmix-generated-value,@JmixGeneratedValue>> указывает, что Jmix должен сгенерировать и назначить первичный ключ при создании экземпляра сущности в памяти.
<5> Аннотация `@jakarta.persistence.Id` указывает первичный ключ.
<6> Аннотация `@jakarta.persistence.Column` определяет сопоставление со столбцом таблицы. Параметр `nullable = false` указывает, что механизм xref:db-migration.adoc[миграции базы данных] должен создать столбец с ограничением `NOT NULL`.
<7> `@jakarta.persistence.Version` указывает, что сущность должна быть оптимистически заблокирована, используя значение этого атрибута. Атрибут должен иметь тип `Integer`. Studio создает такой атрибут автоматически, если вы выберите для сущности черту _Versioned_.
<8> Аннотация <<instance-name,@InstanceName>> указывает здесь на один атрибут, выбранный в качестве имени экземпляра.
<9> Аннотации `@NotNull` и `@Email` из пакета `jakarta.validation.constraints` являются примерами использования в сущностях аннотаций https://beanvalidation.org[Bean Validation^].
<10> Параметр `unique = true` в аннотации `@Column` указывает, что механизм миграции базы данных должен добавить в столбец ограничение уникальности.

Как имя таблицы, так и имя сущности могут иметь префикс для устранения конфликтов с именами сущностей из других модулей. Studio ставит этот префикс, если проект имеет свойство  `jmix.projectId` в `build.gradle`.

[[traits]]
=== Черты

Черта (Trait) – это набор атрибутов, который придает сущности определенное поведение на системном уровне. Эти атрибуты обрабатываются фреймворком и не предназначены для редактирования пользователями или кодом вашего приложения.

Дизайнер сущностей Studio помогает назначать сущностям доступные черты. Вы также можете сделать это вручную, создав соответствующие атрибуты и снабдив их аннотациями, как описано ниже.

[[has-uuid-trait]]
=== Черта Has UUID

Черта _Has UUID_ предоставляет глобально уникальный идентификатор, автоматически назначаемый при создании экземпляра в памяти. Эта черта реализуется атрибутом с типом `UUID` и аннотацией <<jmix-generated-value>>.

TIP: При создании сущности в Studio черта Has UUID применяется автоматически, если вы выбрали UUID в *Id type*. Добавьте черту Has UUID, если вы выбрали другой тип и *Id value*, отличное от значения *Generated by Jmix*.

Эта черта не требует дополнительного атрибута, если вы выбираете тип `UUID` для идентификатора сущности.

Добавление черты Has UUID настоятельно рекомендуется, если вы используете атрибут идентификатора, значение которого не присваивается непосредственно при создании экземпляра сущности в памяти (не имеет аннотации `@JmixGeneratedValue`). Это относится к идентификаторам `Long` и `Integer`, отображенным на колонку с типом identity (то есть присваиваевым базой данных), а также к идентификаторам любого типа, значение которых вводится пользователями. У таких сущностей метод `hashCode()` всегда возвращает постоянное значение, что влияет на производительность коллекций на основе хэш-таблиц.

[[versioned-trait]]
=== Черта Versioned

Черта _Versioned_ обеспечивает оптимистическую блокировку на уровне JPA. Она реализуется целочисленным атрибутом с аннотацией `@Version`.

WARNING: Никогда не изменяйте значение атрибута `@Version` в коде приложения. Это приведет к невозможности обновления экземпляра в базе данных.

[[audit-traits]]
=== Черты Audit

Черты _Audit of creation_ и _Audit of modification_ обеспечивают отслеживание того, кто и когда создал и изменил экземпляр сущности. Они реализуются атрибутами соответствующих типов с аннотациями `@CreatedBy`, `@CreatedDate`, `@LastModifiedBy` и `@LastModifiedDate` из проекта Spring Data.

Например:

[source,java,indent=0]
----
include::example$/data-model-ex1/src/main/java/com/company/demo/entity/Order.java[tags=audit-traits]
----

Атрибуты Audit назначаются автоматически, когда фреймворк сохраняет экземпляры сущностей.

[[soft-delete-trait]]
=== Черта Soft Delete

Черта _Soft Delete_ обеспечивает мягкое удаление экземпляров сущностей. Она реализуется с помощью пары атрибутов с аннотациями `@DeletedDate` и `@DeletedBy`, например:

[source,java,indent=0]
----
include::example$/data-model-ex1/src/main/java/com/company/demo/entity/Order.java[tags=soft-delete-trait]
----

Для более подробной информации перейдите к разделу xref:soft-deletion.adoc[Мягкое удаление].

[[inheritance]]
=== Наследование сущностей

Jmix использует принципы наследования JPA. Дизайнер сущностей Studio автоматически генерирует необходимые аннотации в соответствии с выбранной стратегией наследования. Основные аннотации перечислены ниже.

[[discriminator-column-annotation]]
==== @DiscriminatorColumn

Используется для определения колонки базы данных, отвечающей за различение типов сущностей в случаях стратегий наследования `SINGLE_TABLE` и `JOINED`.

Параметры:

* `name` - имя колонки-дискриминатора.
* `discriminatorType` - тип данных колонки-дискриминатора.
* `length` - длина колонки для типов дискриминаторов на основе строки.

Пример:

[source,java,indent=0]
----
@DiscriminatorColumn(name = "TYPE", discriminatorType = DiscriminatorType.INTEGER)
----

[[discriminator-value-annotation]]
==== @DiscriminatorValue

Определяет значение колонки-дискриминатора для данной сущности.

Пример:

[source,java,indent=0]
----
@DiscriminatorValue("0")
----

[[inheritance-annotation]]
==== @Inheritance

Определяет стратегию наследования для иерархии классов сущностей. Данная аннотация должна быть помещена на корневом классе иерархии.

Параметры:

* `strategy` - стратегия наследования, по умолчанию `SINGLE_TABLE`.

[[mapped-superclass]]
==== @MappedSuperclass

Определяет, что данный класс является предком некоторых сущностей, и его атрибуты должны быть использованы в составе сущностей-наследников. Такой класс не сопоставляется никакой отдельной таблице БД.

[[primary-key-join-column]]
==== @PrimaryKeyJoinColumn

Используется в случае стратегии наследования JOINED для указания колонки внешнего ключа данной сущности, ссылающегося на первичный ключ сущности-предка.

Параметры:

* `name` - имя колонки внешнего ключа данной сущности.
* `referencedColumnName` - имя колонки первичного ключа сущности предка.

Пример:

[source,java,indent=0]
----
@PrimaryKeyJoinColumn(name = "CARD_ID", referencedColumnName = "ID")
----

[[dto]]
== Сущности DTO

Модель данных вашего приложения может содержать сущности, которые существуют только в памяти или отражают некоторые внешние данные, используя механизмы, отличные от JPA. Мы называем их сущностями DTO, потому что они часто используются в качестве Объектов передачи данных (Data Transfer Objects) в параметрах и возвращаемых значениях в xref:rest:index.adoc[универсальном REST] и при взаимодействии с внешними API.

Простой пример DTO-сущности:

.OperationResult.java
[source,java,indent=0]
----
include::example$/data-model-ex1/src/main/java/com/company/demo/entity/OperationResult.java[tags=entity]
----

<1> Обязательная аннотация <<jmix-entity,@JmixEntity>>.
<2> Все свойства объекта (поля с методами доступа) становятся атрибутами сущности.

Атрибуты сущностей могут иметь аннотации для указания каких-либо подробностей о них:

.ProductPart.java
[source,java,indent=0]
----
include::example$/data-model-ex1/src/main/java/com/company/demo/entity/ProductPart.java[tags=entity]
----

<1> Аннотация <<jmix-entity,@JmixEntity>> явно определяет имя сущности.
<2> Аннотация <<jmix-property,@JmixProperty>> с параметром `mandatory = true` указывает, что атрибут является обязательным, т.е. должен содержать значение.
<3> Аннотация <<instance-name,@InstanceName>> указывает здесь на один атрибут, выбранный в качестве имени экземпляра.
<4> Атрибут без аннотации.

Сущности DTO могут быть связаны с xref:data-stores.adoc#custom[пользовательским хранилищем данных] для общих операций CRUD с помощью `DataManager` и поддержки ссылок на сущности DTO из сущностей JPA.

В приведенном ниже примере показано, как исключить некоторые свойства объекта из атрибутов сущности (подробнее об этом в разделе <<attributes>>).

.Metric.java
[source,java,indent=0]
----
include::example$/data-model-ex1/src/main/java/com/company/demo/entity/Metric.java[tags=entity]
----

<1> Аннотация `@Store` указывает пользовательское хранилище данных.
<2> Параметр `annotatedPropertiesOnly = true` аннотации <<jmix-entity,@JmixEntity>> указывает, что свойства объекта, не помеченные с помощью <<jmix-property,@JmixProperty>>, не будут атрибутами сущности.
<3> Аннотация <<jmix-property,@JmixProperty>> с параметром `mandatory = true` указывает, что атрибут является обязательным, т.е. должен содержать значение.
<4> Аннотация <<jmix-id,@JmixId>> указывает, что атрибут является идентификатором сущности.
<5> Аннотация <<jmix-generated-value,@JmixGeneratedValue>> указывает, что Jmix должен сгенерировать и назначить идентификатор при создании экземпляра сущности в памяти.
<6> Аннотация <<jmix-property,@JmixProperty>> здесь просто указывает, что свойство является атрибутом сущности.
<7> Не аннотированное свойство не является атрибутом сущности из-за параметра `annotatedPropertiesOnly = true` аннотации `@JmixEntity`.

[[key-value]]
== Сущность Key-Value

`KeyValueEntity` позволяет представлять произвольные наборы именованных значений в виде сущностей и, следовательно, работать с данными, которые не представлены непосредственно классами Java (сущностями JPA или DTO).

Рассмотрим пример: в вашей модели данных есть сущность `Order`, и вам нужно рассчитать сумму заказов, агрегированных клиентами, и отобразить эти данные в UI. Вы можете выполнить запрос JPQL и загрузить результат в виде списка экземпляров сущности `KeyValueEntity` используя `DataManager`:

[source,java,indent=0]
----
include::example$/data-model-ex1/src/test/java/com/company/demo/KeyValueTest.java[tags=load]
----

Возвращаемые экземпляры `KeyValueEntity` будут иметь два атрибута, которые вы указали в методе `properties()`: `customer` со значением первого поля в списке результатов запроса и `total` со значением второго поля. Вы можете получить их следующим образом:

[source,java,indent=0]
----
include::example$/data-model-ex1/src/test/java/com/company/demo/KeyValueTest.java[tags=get-value]
----

Jmix UI содержит специальные xref:flow-ui:data/key-value-containers.adoc[key-value контейнеры данных] для привязки компонентов пользовательского интерфейса к экземплярам сущности `KeyValueEntity`.

[[attributes]]
== Атрибуты сущности

NOTE: Существует еще один термин для атрибутов сущности: _свойства (properties) сущности_. Он часто используется в кодовой базе Jmix, например, в аннотациях: `@JmixProperty`, `@DependsOnProperties` и т.д.

Каждый атрибут сущности должен иметь соответствующий тип. Jmix поддерживает следующие типы "из коробки":

* `java.lang.String`
* `java.lang.Character`
* `java.lang.Boolean`
* `java.lang.Integer`
* `java.lang.Long`
* `java.lang.Double`
* `java.math.BigDecimal`
* `java.util.Date`
* `java.time.LocalDate`
* `java.time.LocalTime`
* `java.time.LocalDateTime`
* `java.time.OffsetTime`
* `java.time.OffsetDateTime`
* `java.sql.Date`
* `java.sql.Time`
* `java.util.UUID`
* `java.net.URI`
* `byte[]` (массив байтов)
* xref:enumerations.adoc[Перечисление]
* Сущность или набор сущностей (ссылочный атрибут)

Вы можете использовать тип, не указанный в приведенном выше списке, если создадите соответствующую реализацию xref:data-types.adoc[Datatype] и убедитесь, что ваш тип поддерживается базовым xref:data-stores.adoc[хранилищем данных].

CAUTION: Обратите внимание, что примитивные типы Java (`int`, `boolean`, и т.д.) не могут использоваться для атрибутов сущностей.

Для сущностей JPA и DTO существует два типа атрибутов:

* _Атрибут на основе поля_ соответствует полю и паре методов доступа accessor (геттер / сеттер) поля. Имя поля становится именем атрибута.
+
Сеттер может быть опущен, тогда атрибут будет доступен только для чтения.
+
Пример атрибута на основе поля:
+
.User.java
[source,java,indent=0]
----
include::example$/data-model-ex1/src/main/java/com/company/demo/entity/User.java[tags=field-based-attr-1;field-based-attr-2]
----

* _Атрибут на основе метода_ соответствует методу без параметров, возвращающему поддерживаемый тип и с именем, начинающимся с `get`, например `getCustomer()`. Имя метода без `get` с первой буквой в нижнем регистре становится именем атрибута: `getFullName()` -> `fullName`.
+
Пример атрибута на основе метода:
+
.User.java
[source,java,indent=0]
----
include::example$/data-model-ex1/src/main/java/com/company/demo/entity/User.java[tags=method-based-attr]
----

Класс сущностей может иметь свойства (поле + геттер/сеттер) и методы, которые не являются атрибутами сущности, то есть не включены в метаданные. Таким образом, вы можете использовать такие свойства и методы в коде вашего приложения, но фреймворк не распознает их и не будет отображать в UI или передавать через REST API.

Становится ли свойство или квалифицирующий метод атрибутом сущности, зависит от следующих правил:

* Если параметр `annotatedPropertiesOnly` аннотации <<jmix-entity,@JmixEntity>> имеет значение `false` (по умолчанию), следующие свойства объекта становятся атрибутами сущности:
+
--
* Для сущностей JPA: все свойства, кроме аннотированных `@jakarta.persistence.Transient`.
* Для сущностей DTO: все свойства.
* В обоих случаях: все свойства и методы с аннотацией <<jmix-property,@JmixProperty>>.
--

* Если параметр `annotatedPropertiesOnly` имеет значение `true`, только свойства и методы с аннотацией <<jmix-property,@JmixProperty>> становятся атрибутами сущности.

[[references]]
== Ссылки

Ссылочные атрибуты определяют отношения между сущностями. Ссылки могут быть одиночными значениями (отношения "to-one") или коллекциями (отношения "to-many").

По умолчанию связь является _ассоциацией_, что означает, что обе сущности могут существовать независимо друг от друга, без владения. Например, в связи Customer - Order у Order (заказа) есть атрибут, который является ссылкой на Customer (клиента). Пользователи самостоятельно создают клиентов и заказы, выбирают клиента для заказа и при необходимости меняют ссылку на другого клиента.

Jmix также поддерживает более сильную связь между сущностями – _композицию_. Композиция подразумевает владение, т.е. экземпляр сущности может существовать только как часть сущности-владельца. Например, в связи Order - OrderLine (строка заказа) у Order есть атрибут, который представляет собой коллекцию экземпляров OrderLine. Каждый экземпляр OrderLine создается для определенного Order, становится его частью и не может принадлежать другому Order.

Объекты, принадлежащие композиции, редактируются в UI вместе. Например, пользователь открывает экран редактирования Order и может создавать и редактировать OrderLines в их отдельных экранах редактирования, но все изменения как для Order, так и для всех его OrderLines сохраняются в базе данных вместе в одной транзакции и только после того, как пользователь подтвердит сохранение объекта-владельца – Order.

Для более подробной информации о композиции обратитесь к руководству xref:data-modeling-composition-guide:index.adoc[].

Отношение-композиция определяется аннотацией <<composition,@Composition>> к ссылочному атрибуту.

TIP: Дизайнер сущностей Studio позволяет выбрать тип отношения в поле *Attribute type*.

[[cross-data-store-ref]]
== Ссылки между сущностями из разных хранилищ

`DataManager` автоматически поддерживает TO-ONE ссылки между сущностями из разных xref:data-stores.adoc[хранилищ], если они объявлены нужным образом.

TIP: Дизайнер сущностей Studio автоматически поддерживает набор атрибутов для ссылок между сущностями из разных хранилищ, если в качестве ассоциации выбирается сущность из другого хранилища.

Рассмотрим пример: у вас есть сущность `Customer` в основном хранилище данных и сущность `Address` в дополнительном хранилище данных, и вы хотите получить ссылку от `Customer` на `Address`. Тогда сущность `Customer` должна содержать следующие два атрибута:

[source,java,indent=0]
----
include::example$/data-model-ex1/src/main/java/com/company/demo/entity/Customer.java[tags=cross-datastore-ref]
----

<1> Атрибут `addressId` хранит идентификатор сущности `Address`. Этот атрибут аннотирован как `@SystemLevel`, чтобы указать фреймворку, что атрибут не должен отображаться пользователям.
<2> Атрибут `address` содержит ссылку на сущность `Address`. Этот атрибут является неперсистентным (т.е. не хранится в базе данных) и аннотирован как <<depends-on-properties,@DependsOnProperties>>, чтобы указать фреймворку, что значение этого атрибута зависит от другого атрибута.

После этого, когда вы загружаете `Customer` с фетч-планом, включающим атрибут `address`, `DataManager` автоматически загружает связанный `Address` из дополнительного хранилища данных. Фреймворк оптимизирует загрузку коллекций для повышения производительности: после загрузки списка клиентов он загружает ссылки из дополнительного хранилища данных частями. Размер частей определяется свойством приложения xref:ROOT:app-properties.adoc#jmix.core.cross-data-store-reference-loading-batch-size[jmix.core.cross-data-store-reference-loading-batch-size].

Когда вы сохраняете граф сущностей, который включает `Customer` с `Address`, `DataManager` сохраняет экземпляры с помощью соответствующих реализаций `DataStore`, а затем сохраняет идентификатор адреса в атрибуте `addressId` клиента.

[[instantiation]]
== Создание экземпляров сущностей

При создании экземпляров сущностей JPA и DTO используйте соответствующий интерфейс фреймворка вместо вызова конструктора класса с оператором `new`. Только в этом случае фреймворк сможет инициализировать поля с аннотациями <<jmix-generated-value,@JmixGeneratedValue>> и вызывать методы <<post-construct,@PostConstruct>>.

Наиболее общим методом создания экземпляров сущностей является `Metadata.create()`:

[source,java,indent=0]
----
include::example$/data-model-ex1/src/main/java/com/company/demo/bean/OrderService.java[tags=metadata-create]
----

Если вы пишете бизнес-логику и в вашем коде уже есть xref:data-access:data-manager.adoc[DataManager], используйте его метод `create()`, что просто избавит вас от необходимости дополнительно инжектировать бин `Metadata`. Например:

[source,java,indent=0]
----
include::example$/data-model-ex1/src/main/java/com/company/demo/bean/OrderService.java[tags=data-manager-create]
----

На экране UI вы можете использовать один из двух методов, описанных выше. Чтобы созданный экземпляр автоматически сохранялся с помощью xref:flow-ui:data/data-context.adoc[DataContext] экрана, используйте метод `DataContext.create()`. Он создает экземпляр и сразу же помещает его в контекст, чтобы начать отслеживать изменения экземпляра. В приведенном ниже примере мы создаем экземпляр сущности `ProductPart`, помещаем его в `DataContext` и добавляем в контейнер данных для отображения в UI таблице:

[source,java,indent=0]
----
include::example$/data-model-ex1/src/main/java/com/company/demo/view/product/ProductDetailView.java[tags=data-context-create]
----

[[uniqueness]]
== Уникальность

Jmix полагается на ограничения уникальности БД для поддержания уникальности экземпляров сущностей. Поэтому, если вы хотите сделать атрибут сущности или набор атрибутов уникальными, следует создать соответствующий индекс для таблицы базы данных.

xref:studio:entity-designer.adoc[Дизайнер сущностей] Studio содержит вкладку *Indexes* для определения уникальных индексов. Эти определения хранятся в аннотации `@Table` сущности и позже используются генератором файлов Liquibase changelog для создания индексов в схеме базы данных.

NOTE: Jmix никоим образом не интерпретирует атрибут `unique = true` аннотации `@Column`.

// todo flowui
// См. раздел xref:ui:exception-handlers/unique-constraint-violation-exception.adoc[] о том, как настроить сообщения, отображаемые фреймворком для ошибок, связанных с нарушением ограничений уникальности.

Если вы хотите определить уникальный атрибут для сущности с чертой Soft Delete, обратитесь к разделу xref:data-model:soft-deletion.adoc#unique-constraints[Мягкое удаление].

[[jmix-annotations]]
== Аннотации сущностей Jmix

Аннотации сущностей Jmix описаны ниже в алфавитном порядке.

NOTE: Сущности в Jmix также могут иметь аннотации для сопоставлений JPA, <<audit-traits,черт audit>> и xref:soft-deletion.adoc[мягкого удаления].

[[comment]]
=== @Comment

Аннотация `@Comment` используется для добавления комментариев к сущностям модели данных и их атрибутам, например:

[source,java,indent=0]
----
include::example$/data-model-ex1/src/main/java/com/company/demo/entity/Location.java[tags=comment]
----

Для всех баз данных, кроме HSQL, Studio генерирует операции изменения Liquibase `setTableRemarks` и `setColumnRemarks` для сохранения комментариев в схеме базы данных. Таким образом, комментарии становятся доступными через любой инструмент инспекции базы данных.

Вы также можете извлекать комментарии из метаданных (или непосредственно из аннотаций класса) для отображения в пользовательском интерфейсе приложения или генерации документации. Используйте для этого методы `MetadataTools.getMetaAnnotationValue()`.

TIP: Studio поддерживает создание комментариев в xref:studio:entity-designer.adoc[дизайнере сущностей]. Для этого существуют редактируемые ссылки *Comment* в списках параметров сущности и атрибута. Когда комментарий установлен, ссылка показывает его первые несколько слов.

[[composition]]
=== @Composition

Аннотация `@Composition` на ссылочном атрибуте указывает, что связь является <<references,композицией>>. Например:

[source,java,indent=0]
----
include::example$/data-model-ex1/src/main/java/com/company/demo/entity/Order.java[tags=composition]
----

[[db-view]]
=== @DbView

Аннотация `@DbView` указывает, сопоставлена ли JPA сущность с представлением базы данных. Сценарии миграции базы данных не генерируются для таких сущностей.

[[ddl-generation]]
=== @DdlGeneration

Аннотация `@DdlGeneration` определяет, должны ли средства разработки генерировать DDL-скрипты для этой сущности.

Режим генерации скриптов устанавливается с помощью перечисления `DbScriptGenerationMode`:

* `CREATE_AND_DROP` - полная генерация скриптов инициализации и обновления;
* `CREATE_ONLY` - полная генерация скриптов инициализации. Скрипты обновления генерируются без инструкций по удалению столбцов;
* `DISABLED` - скрипты инициализации и обновления не генерируются.

Значение по умолчанию: `CREATE_AND_DROP`.

Также генерацию скриптов можно точно настроить, используя следующие атрибуты:

* `unmappedColumns` - список столбцов, которые существуют в базе данных, но не должны быть сопоставлены с сущностью. Скрипты удаления для этих столбцов сгенерированы не будут;
* `unmappedConstraints` - список ограничений и индексов, которые существуют в базе данных, но не должны быть сопоставлены с сущностью. Скрипты удаления для этих столбцов сгенерированы не будут.

[[depends-on-properties]]
=== @DependsOnProperties

Аннотация `@DependsOnProperties` определяет свойства сущности, от которых зависит аннотированный атрибут. Эти свойства учитываются при построении фетч-планов и при загрузке/сохранении ссылок на сущности из разных хранилищ данных. Кроме того, если аннотированное свойство доступно только для чтения (без сеттера), для этого свойства отправляется `EntityPropertyChangeEvent` при изменении указанных атрибутов.

Вы можете указать только непосредственные локальные и ссылочные свойства. Такие пути к свойствам, как `customer.name` не поддерживаются.

[[instance-name]]
=== @InstanceName

_Instance name_ – это понятный пользователю текст, представляющий экземпляр сущности. Думайте об этом как о методе `toString()` на уровне приложения. Он часто используется в UI при отображении экземпляра сущности в одном поле или ячейке таблицы. Вы также можете получить имя экземпляра программно, используя метод `MetadataTools.getInstanceName()`.

Аннотация `@InstanceName` может присутствовать в одном поле или методе объекта.

В первом случае в качестве имени экземпляра используется аннотированное значение атрибута. Например:

[source,java,indent=0]
----
@InstanceName
@Column(name = "NAME")
private String name;
----

Если вы хотите сгенерировать что-то более сложное, чем одно значение атрибута, создайте метод, возвращающий `String` в классе сущности. Например:

[source,java,indent=0]
----
include::example$/data-model-ex1/src/main/java/com/company/demo/entity/GeoPointEntity.java[tags=instance-name]
----

Метод принимает любые Spring бины в качестве параметров. В приведенном выше примере бин `Messages` используется для форматирования имени экземпляра в соответствии с текущей локалью пользователя.

Аннотация <<depends-on-properties,@DependsOnProperties>> к методу имени экземпляра необходима, поскольку она определяет атрибуты встроенного фетч-плана `_instance_name`.


[[jmix-entity]]
=== @JmixEntity

`@JmixEntity` – это обязательная аннотация, указывающая, что класс является сущностью Jmix.

Если класс аннотирован `@jakarta.persistence.Entity`, фреймворк получает от него имя сущности для метаданных, и `@JmixEntity` не должен указывать параметр `name`. В противном случае укажите имя сущности в параметре `name`. Если ни у `@JmixEntity`, ни у `@jakarta.persistence.Entity` нет параметра `name`, имя сущности равно простому имени класса Java.

Параметр `annotatedPropertiesOnly` указывает, какие свойства объекта становятся атрибутами сущности. См. <<attributes>> для получения более подробной информации.

[[jmix-generated-value]]
=== @JmixGeneratedValue

Аннотация `@JmixGeneratedValue` указывает, что фреймворк должен сгенерировать и назначить значение атрибута сущности при создании экземпляра сущности в памяти.

Аннотированный атрибут должен быть типа `Long`, `Integer` или `UUID`, и сущность не должна иметь более одного `UUID` атрибута, отмеченного этой аннотацией.

CAUTION: Обратите внимание, что аннотация `@JmixGeneratedValue` не вступает в силу, если вы создаете экземпляр сущности с помощью оператора `new`. См. надлежащие методы создания новых экземпляров в разделе <<instantiation>>.

[[jmix-id]]
=== @JmixId

Аннотация `@JmixId` указывает идентификатор сущности для <<dto,сущностей DTO>>. Вы должны явно выбрать идентификатор, если ваша сущность DTO сопоставлена с некоторыми внешними данными, и вам нужно многократно загружать/сохранять ее экземпляры, потому что в этом случае вам необходимо поддерживать идентификацию объекта на протяжении всего жизненного цикла сущности.

Вы можете использовать существующий атрибут как идентификатор, если атрибут содержит уникальные значения, например:

[source,java]
----
@JmixId
private String code;
----

Если такого естественно уникального атрибута нет, определите его и также аннотируйте <<jmix-generated-value,@JmixGeneratedValue>>, чтобы присвоить уникальное значение при создании экземпляра:

[source,java]
----
@JmixId
@JmixGeneratedValue
private UUID id;
----

[[jmix-property]]
=== @JmixProperty

Аннотация `@JmixProperty` указывает, что поле или метод объекта является атрибутом сущности. Дополнительные сведения см. в разделе <<attributes>>.

Используйте параметр `mandatory`, если хотите указать, что для атрибута требуется значение, а поле объекта не содержит JPA аннотацию `@Column`, в которой вы могли бы задать `nullable = false`.

[[number-format]]
=== @NumberFormat

Задает формат атрибута типа `Number` (это может быть `BigDecimal`, `Integer`, `Long` или `Double`). Значения такого атрибута будут форматироваться в пользовательском интерфейсе в соответствии c параметрами, указанными в аннотации:

* `pattern` - паттерн форматирования, задается по правилам, описанным в https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/text/DecimalFormat.html[DecimalFormat^].

* `decimalSeparator` - символ, используемый в качестве разделителя целой и дробной части (опционально).

* `groupingSeparator` - символ, используемый в качестве разделителя групп разрядов (опционально).

NOTE: Если `decimalSeparator` и/или `groupingSeparator` не указаны, то при форматировании с учетом локали будут использованы символы из xref:data-model:data-types.adoc#localized-format-strings[локали текущего пользователя]. При форматировании без учета локали используются символы из системной локали сервера.

Примеры:

[source,java,indent=0]
----
include::example$/data-model-ex1/src/main/java/com/company/demo/entity/Formatters.java[tags=number-format]
----

[[on-delete]]
=== @OnDelete

Аннотация `@OnDelete` может использоваться для ссылочных атрибутов сущностей с xref:soft-deletion.adoc[мягким удалением]. Она определяет, что должно произойти с ссылаемой сущностью, когда сущность, содержащая аннотацию (_данная_ сущность), удаляется.

Аннотация может иметь одно из следующих значений:

* `DeletePolicy.DENY` – выбросить исключение при попытке удалить данную сущность, если ссылка не равна null.

* `DeletePolicy.CASCADE` – удалить ссылаемые сущности вместе с данной сущностью.

* `DeletePolicy.UNLINK` – отсоединить ссылаемую сущность, установив атрибут ссылки в null. Используйте это значение только на владеющей стороне отношения (той, у которой есть аннотация `@JoinColumn`).

[[on-delete-inverse]]
=== @OnDeleteInverse

Аннотация `@OnDelete` может использоваться для ссылочных атрибутов сущностей с xref:soft-deletion.adoc[мягким удалением] и обычных жестко удаляемых сущностей. Она определяет, что должно произойти с сущностью, содержащей аннотацию (_данной_ сущностью), когда ссылаемая сущность удаляется.

Аннотация может иметь одно из следующих значений:

* `DeletePolicy.DENY` – выбросить исключение при попытке удалить ссылаемую сущность.

* `DeletePolicy.CASCADE` – удалить данную сущность вместе со ссылаемой сущностью.

* `DeletePolicy.UNLINK` – установить атрибут ссылки в null.

Для сущностей с мягким удалением `@OnDeleteInverse` обрабатывается фреймворком во время выполнения приложения. Значения `DENY` и `CASCADE` могут использоваться как на владеющей стороне (той, у которой есть аннотация `@JoinColumn`), так и на не владеющей (`mappedBy`) сторонах отношения. Значение `UNLINK` следует использовать только на владеющей стороне.

Для обычных жестко удаляемых сущностей `@OnDeleteInverse` со значениями `CASCADE` и `UNLINK` обрабатывается Studio при генерации Liquibase changelogs. Его нужно использовать только на владеющей стороне отношения (той, у которой есть аннотация `@JoinColumn`) и это приводит к созданию ограничения внешнего ключа с параметрами `ON DELETE CASCADE` или `ON DELETE SET NUll`.

[[post-construct]]
=== @PostConstruct

Используйте аннотацию `jakarta.annotation.PostConstruct` на методе, который выполняет инициализацию нового экземпляра сущности. Например:

[source,java,indent=0]
----
include::example$/data-model-ex1/src/main/java/com/company/demo/entity/Customer.java[tags=post-construct]
----

Аннотированный метод принимает любые Spring бины. В приведенном ниже примере мы используем бин `TimeSource` для инициализации атрибута `date`:

[source,java,indent=0]
----
include::example$/data-model-ex1/src/main/java/com/company/demo/entity/Order.java[tags=post-construct]
----

CAUTION: Обратите внимание, что аннотированный метод `@PostConstruct` не вызывается, если вы создаете экземпляр сущности с помощью оператора `new`. См. надлежащие методы создания новых экземпляров в разделе <<instantiation>>.

[[property-datatype]]
=== @PropertyDatatype

Если у вас есть несколько xref:data-types.adoc[типов данных] для Java-типа атрибута сущности, аннотация `@PropertyDatatype` позволяет прямо указать реализацию `Datatype` по ее идентификатору.

[source,java,indent=0]
----
include::example$/data-model-ex1/src/main/java/com/company/demo/entity/Model.java[tags=datatype]
----

[[store]]
=== @Store

Используйте аннотацию `@Store` для класса сущности, чтобы связать сущность с дополнительным xref:data-stores.adoc[хранилищем данных].

[[system-level]]
=== @SystemLevel

Аннотация `@SystemLevel` указывает, что аннотированная сущность или ее атрибут являются низкоуровневыми и не должны отображаться в пользовательском интерфейсе.