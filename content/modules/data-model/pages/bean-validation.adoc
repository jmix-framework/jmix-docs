= Bean Validation

Java Bean Validation — это спецификация для валидации данных в приложениях на Java. Текущая версия 2.0 спецификации доступна https://beanvalidation.org/specification/[здесь^].  Эталонной реализацией Bean Validation является https://docs.jboss.org/hibernate/stable/validator/reference/en-US/html_single/?v=5.3[Hibernate Validator^].

Использование Bean Validation дает следующие преимущества:

* Логика валидации расположена рядом с предметной областью: определение ограничений для полей и методов бина происходит естественным и по-настоящему объектно-ориентированным образом.
* Стандарт Bean Validation дает десятки https://docs.jboss.org/hibernate/stable/validator/reference/en-US/html_single/#validator-defineconstraints-spec[валидационных аннотаций^] прямо из коробки, например: `@NotNull`, `@Size`, `@Min`, `@Max`, `@Pattern`, `@Email`, `@Past`, не совсем стандартные `@URL`, `@Length`, и многие другие.
* Вы не лимитированы предопределенными ограничениями и можете определять свои собственные аннотации ограничений. Вы также можете создать новую аннотацию, объединив несколько других, или создать совершенно новую и определить класс Java, который будет служить в качестве средства проверки.
+
Например, вы можете определить <<custom-constraints,аннотацию на уровне класса>> `@ValidPassportNumber`, чтобы проверить, соответствует ли номер паспорта правильному формату, который зависит от значения поля `location`.
* Ограничения можно ставить не только на поля или классы, но и на методы и их параметры. Этот подход называется <<validation-by-contract,"validation by contract">>.

Bean Validation вызывается автоматически в xref:flow-ui:views/view-validation.adoc[экранах UI], когда пользователь отправляет введенную информацию, а также в универсальном xref:rest:index.adoc[REST API].

[[defining-constraints]]
== Определение ограничений

Ограничения Bean Validation определяются с помощью аннотаций пакета `javax.validation.constraints` или собственных аннотаций. Аннотации указываются на декларации класса сущности или POJO, на поле или getter-методе, а также на методе сервиса.

Стандартный набор ограничений включает наиболее часто используемые и универсальные. Кроме того, Bean Validation позволяет разработчикам добавлять <<custom-constraints,собственные ограничения>>.

* `@NotNull` проверяет, что значение аннотированного свойства не равно `null`.
* `@Size` проверяет, что значение аннотированного свойства имеет размер между атрибутами `min` и `; max` может применяться к свойствам `String`, `Collection`, `Map`, и массивам.
* `@Min` проверяет, что аннотированное свойство имеет значение выше или равное атрибуту `value`.
* `@Max` проверяет, что аннотированное свойство имеет значение, меньшее или равное атрибуту `value`.
* `@Email` проверяет, что аннотированное свойство является допустимым адресом электронной почты.
* `@NotEmpty` проверяет, что свойство не является `null` или пустым; может применяться к значениям `String``, `Collection`, `Map` или `Array`.
* `@NotBlank` может применяться только к текстовым значениям и проверяет, что значение свойства не является `null` или пробельным символом.
* `@Positive` и `@PositiveOrZero` применяются к числовым значениям и проверяют, что они строго положительны или положительны, включая 0.
* `@Negative` и `@NegativeOrZero` применяются к числовым значениям и проверяют, что они строго отрицательные или отрицательные, включая 0.
* `@Past` и `@PastOrPresent` проверяют, что значение даты находится в прошлом или в прошлом, включая настоящее.
* `@Future` и `@FutureOrPresent` проверяют, что значение даты находится в будущем или в будущем, включая настоящее.
* `@Pattern` проверяет, соответствует ли свойство аннотированной строки регулярному выражению `regex`.

//TODO: добавить информацию, как задать перечисленные аннотации для сущностей в Studio. Подождать, когда появится соответствующий подраздел и дать на него ссылку

[[entity-bean-validation]]
=== Bean Validation сущности

Пример использования стандартных аннотаций валидации на полях сущности:

.Person.java
[source,java,indent=0]
----
include::example$/data-model-ex1/src/main/java/com/company/demo/entity/Person.java[tags=entity-start;entity-fields;entity-end]
----

<1> Длина имени человека должна быть более 3 символов.
<2> Строка электронной почты должна быть адресом электронной почты в правильном формате.
<3> Рост человека должен быть больше 0.
<4> Рост человека должен быть меньше или равен 300.

Давайте проверим, как автоматически выполняется валидация бина, когда пользователь отправляет данные в UI.

image::validation-ui.png[align="center"]

Как видите, приложение не только показывает пользователю сообщения об ошибках, но также выделяет красными линиями поля формы, которые не прошли bean-валидацию с одним полем.

[[custom-constraints]]
==== Собственные ограничения

В проекте можно создать собственные ограничения с программной или декларативной валидацией.

Для создания ограничения с программной валидацией выполните следующее:

. Создайте аннотацию:
+
[source,java,indent=0]
----
include::example$/data-model-ex1/src/main/java/com/company/demo/entity/validation/ValidPassportNumber.java[tags=annotation]
----
<1>	Определяет, что целью этой аннотации времени выполнения является класс или интерфейс.
<2> Указывает, что реализация аннотации находится в классе `ValidPassportNumberValidator`.

. Создайте класс валидатора:
+
[source,java,indent=0]
----
include::example$/data-model-ex1/src/main/java/com/company/demo/entity/validation/ValidPassportNumberValidator.java[tags=validator]
----
<1> Фактически, проверку выполняет метод `isValid()`.

. Используйте аннотацию уровня класса:
+
[source,java,indent=0]
----
include::example$/data-model-ex1/src/main/java/com/company/demo/entity/Person.java[tags=custom-validation-annotation;entity-start;entity-end]
----

Собственные аннотации могут также быть созданы как композиции имеющихся, например:

[source,java,indent=0]
----
include::example$/data-model-ex1/src/main/java/com/company/demo/entity/validation/ValidZipCode.java[tags=annotation]
----

При использовании композитных ограничений результирующий набор нарушений будет содержать отдельные записи для каждого включенного ограничения. Для того чтобы получить одну запись нарушения, добавьте `ReportAsSingleViolation` классу вашей аннотации.

[[validation-by-contract]]
=== Валидация по контракту

При Bean Validation ограничения могут применяться к входным параметрам и возвращаемым значениям методов и конструкторов для проверки предусловий и постусловий их вызовов у любого Java класса. Это называется «validation by contract».

Благодаря подходу «валидация по контракту» вы получаете понятный, компактный и легко поддерживаемый код.

Службы выполняют валидацию параметров и результатов, если метод имеет аннотацию `@Validated` в интерфейсе службы. Например:

[source,java,indent=0]
----
include::example$/data-model-ex1/src/main/java/com/company/demo/service/PersonApiService.java[tags=person-api-service]
----
<1> Указывает, что каждый объект в списке, возвращаемом методом `getPersons()`, также должен быть проверен на соответствие ограничениям класса `Person`.
<2> Указывает, что метод должен быть проверен.
<3> Аннотацию `@Valid` можно использовать, если вам нужна каскадная валидация параметров метода. В приведенном выше примере также будут проверены ограничения, объявленные для объекта `Person`.

Если вы выполняете собственную программную валидацию в службе, используйте `CustomValidationException` для информирования клиентов об ошибках валидации в том же формате, что и стандартная Bean Validation. Это может быть особенно актуально для клиентов REST API.

[NOTE]
Bean Validation наследуется. Если вы аннотируете какой-либо класс, поле или метод ограничением, все наследники, которые расширяют или реализуют этот класс или интерфейс, будут затронуты одной и той же проверкой ограничения.

[[constraint-groups]]
=== Группы ограничений

Группы ограничений позволяют применять только часть всех определенных ограничений в зависимости от логики приложения. Например, возможно, вы захотите заставить пользователя ввести значение атрибута сущности, но имея возможность установить этот атрибут в `null` с помощью какого-то внутреннего механизма. Для этого необходимо указать атрибут группы `groups` в аннотации ограничения. Тогда ограничение вступит в силу только тогда, когда та же группа будет передана механизму валидации.

Фреймворк передает следующие группы ограничений механизму валидации:

* `RestApiChecks` - группа ограничений bean validation, используемая xref:jmix:rest:index.adoc[REST API] для валидации данных.
* `UiComponentChecks` - группа ограничений bean validation, используемая пользовательским интерфейсом для валидации полей.
* `UiCrossFieldChecks` -  группа ограничений bean validation, используемая пользовательским интерфейсом для перекрестной валидации.
* `javax.validation.groups.Default` - эта группа передается всегда, кроме как при коммите редактора UI.

[[validation-messages]]
=== Cообщения валидации

У ограничений могут быть сообщения для отображения пользователям.

Сообщения можно задавать прямо в валидационных аннотациях, например:

[source,java,indent=0]
----
include::example$/data-model-ex1/src/main/java/com/company/demo/entity/Person.java[tags=message1]
----

Сообщение также можете поместить в xref:localization:message-bundles.adoc[пакет сообщений] и указать ключ сообщения в аннотации. Например:

[source,java,indent=0]
----
include::example$/data-model-ex1/src/main/java/com/company/demo/entity/Person.java[tags=message2]
----

Сообщения могут содержать параметры и выражения. Параметры заключены в `{}` и представляют собой либо локализованные сообщения, либо параметры аннотаций, например `+{min}+`, `+{max}+`, `+{value}+`. Выражения заключены в `${}` и могут включать переменную проверенного значения `validatedValue`, параметры аннотации, такие как `value` или `min`, и выражения JSR-341 (EL 3.0). Например:

[source,java,indent=0]
----
include::example$/data-model-ex1/src/main/java/com/company/demo/entity/Person.java[tags=message3]
----

Локализованные значения сообщений также могут содержать параметры и выражения.

// TODO after https://github.com/jmix-framework/jmix/issues/686
//=== Validation of Related Objects

[[running-validation]]
== Выполнение валидации

// todo flowui
[[ui-validation]]
=== Валидация в UI

Компоненты пользовательского интерфейса, связанные с данными, автоматически получают `BeanPropertyValidator` для проверки значения поля. Валидатор вызывается из метода `Validatable.validate()`, реализованного визуальным компонентом, и может выбросить исключение `ValidationException`.

// Стандартный валидатор можно удалить или инициализировать с другой <<constraint-groups,группой ограничений>>:
//
// [source,java,indent=0]
// ----
// include::example$/data-model-ex1/src/main/java/com/company/demo/view/person/PersonDetailView.java[tags=person-edit-start;set-or-remove;person-edit-end]
// ----
// <1> Полностью удаляет bean validation из компонента UI.
// <2> Здесь валидаторы проверяют только ограничения с явно заданной группой `UiComponentChecks`, потому что группа `Default` передана не будет.

По умолчанию `AbstractBeanValidator` имеет обе группы `Default` и `UiComponentChecks`.

Если атрибут сущности аннотирован `@NotNull` без групп ограничений, он будет помечен как обязательный в метаданных, а компоненты пользовательского интерфейса, связанные с данными, будут иметь `required = true`.

Компоненты xref:flow-ui:vc/components/datePicker.adoc[], xref:flow-ui:vc/components/dateTimePicker.adoc[] и xref:flow-ui:vc/components/timePicker.adoc[] автоматически устанавливают свой допустимый диапазон в соответствии с аннотациями `@Past`, `@PastOrPresent`, `@Future`, `@FutureOrPresent`.

Экраны xref:flow-ui:views/view-classes.adoc#standard-detail-view[деталей сущностей] выполняют валидацию на соответствие ограничениям уровня класса при коммите, если ограничение включает группу `UiCrossFieldChecks` и если все проверки на уровне атрибутов пройдены.

//Вы можете отключить валидацию такого рода с помощью метода контроллера `setCrossFieldValidate()`:
//
// [source,java,indent=0]
// ----
// include::example$/data-model-ex1/src/main/java/com/company/demo/view/person/PersonDetailView.java[tags=person-edit-start;set-cross-field-validate;person-edit-end]
// ----

[[rest-api-validation]]
=== Валидация в REST API

Универсальный REST API автоматически выполняет Bean Validation для xref:rest:entities-api/create-entities.adoc#entity-validation[создания и обновления] действий, а также при использовании подхода xref:rest:business-logic.adoc#services-api[Services API].

[[programmatic-validation]]
=== Программная валидация

Вы можете выполнить Bean Validation программно, используя метод `validate()` интерфейса `javax.validation.Validator`. Результатом валидации является набор объектов `ConstraintViolation`. Например:

[source,java,indent=0]
----
include::example$/data-model-ex1/src/main/java/com/company/demo/view/person/PersonListView.java[tags=validator;save]
----