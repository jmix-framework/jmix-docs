= 数据存储

数据存储表示应用程序中的数据库或任何其他数据源。

Jmix 核心子系统提供了 `JpaDataStore`，将 xref:entities.adoc#jpa[JPA 实体] 存储在关系型数据库中。这是 Jmix 应用程序中主要的持久化机制，如果没有明确说明，在本手册中提到数据存储都是指 `JpaDataStore`。

xref:rest-ds:index.adoc[] 扩展组件提供了 `RestDataStore`，用于处理远端 Jmix 应用程序通过 xref:rest:index.adoc[] 开放的 xref:entities.adoc#jpa[DTO 实体]。

[[main]]
== 主数据存储

当使用 Studio 创建一个新的 Jmix 项目时，会带有有一个名为 _main_ 的数据存储用来连接到一个关系型数据库。连接参数通过以下应用程序属性指定：

[source,properties]
----
include::example$/data-model-ex1/src/main/resources/application.properties[tags=main-data-store]
----

TIP: 可以使用 Studio 图形界面为数据存储定义数据库连接参数。

主应用程序类包含一个对应的 JDBC `DataSource` bean 声明：

[source,java,indent=0]
----
include::example$/data-model-ex1/src/main/java/com/company/demo/DataModelEx1Application.java[tags=main-data-source]
----

所有的 JPA 实体均默认关联到主数据存储。

[[additional]]
== 附加数据存储

如果需要处理多个数据库，需要附加数据存储。

TIP: 可以使用 Studio 图形界面定义附加数据存储。

每个附加数据存储都有唯一的名称，该名称在 `jmix.core.additional-stores` 应用程序属性指定，该属性是一个以逗号作为分隔符的列表。数据库连接的参数以数据存储的名称作为前缀。在下面的示例中，配置了一个名称为 `locations` 的附加数据存储：

[source,properties]
----
include::example$/data-model-ex1/src/main/resources/application.properties[tags=add-data-store]
----

对于每个额外数据存储，Studio 会创建一个 Spring 配置类并在其中定义 JDBC `DataSource` 和其他相关的 bean：

[source,java,indent=0]
----
include::example$/data-model-ex1/src/main/java/com/company/demo/LocationsStoreConfiguration.java[tags=add-data-source]
----

要将一个实体与附加数据存储关联，用 `@Store` 注解：

[source,java,indent=0]
----
include::example$/data-model-ex1/src/main/java/com/company/demo/entity/Country.java[tags=store-ann]
----

TIP: 当你在实体设计器中为实体选择附加数据存储时，Studio 会帮你添加 `@Store` 注解。

在上面的示例中，`Country` 实体将被存储在 `locations` 数据存储连接的数据库中。

[[custom]]
== 自定义数据存储

自定义数据存储支持以处理 JPA 实体相同的方式处理某些 DTO 实体 - 通过使用 `DataManager`。如果你的 DTO 实体与自定义数据存储关联，则 `DataManager` 会代理定制数据存储的 CRUD 操作，并能处理其他实体对 DTO 的引用。

我们来看一下创建自定义数据存储的过程。假设一个 transient 的 `Metric` 实体，存储在内存中。

. 创建一个实现 `DataStore` 接口的类。该类必须是 Spring prototype bean。下面是一个能够在内存中存储不同类型实体的基本实现。
+
[source,java,indent=0]
----
include::example$/data-model-ex1/src/main/java/com/company/demo/store/InMemoryStore.java[tags=custom-store-1;custom-store-2]
----

. 创建一个实现 `StoreDescriptor` 接口的类。必须是一个 Spring singleton bean，其 `getBeanName()` 方法必须返回上一步创建的实现 `DataStore` bean 的名称：
+
[source,java,indent=0]
----
include::example$/data-model-ex1/src/main/java/com/company/demo/store/InMemoryStoreDescriptor.java[tags=custom-store]
----

. 将数据存储名称（在本例中为 `inmem`）添加到 `jmix.core.additionalStores` 属性：
+
[source,properties]
----
include::example$/data-model-ex1/src/main/resources/application.properties[tags=custom-data-store-1]
----

. 在 `jmix.core.store-descriptor-<store_name>` 属性中设置 `StoreDescriptor` bean 名称：
+
[source,properties]
----
include::example$/data-model-ex1/src/main/resources/application.properties[tags=custom-data-store-2]
----

. 为实体添加 `@Store` 注解：
+
[source,java,indent=0]
----
include::example$/data-model-ex1/src/main/java/com/company/demo/entity/Metric.java[tags=custom-store]
----
<1> `@Store` 注解指定了一个自定义数据存储。
<2> 参阅 xref:data-model:entities.adoc#jmix-entity[@JmixEntity] 的解释。

. 现在你可以使用 `DataManager` 保存和加载实体了，它会帮你代理自定义数据库存储的 CRUD 操作：
+
[source,java,indent=0]
----
include::example$/data-model-ex1/src/test/java/com/company/demo/EntitiesTest.java[tags=custom-store]
----
+
此外，如果另一个实体引用了 `Metric`，则在访问该引用属性时会自动加载 `Metric` 实例。
