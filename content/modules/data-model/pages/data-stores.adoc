= Хранилища данных

Хранилище представляет собой базу данных или любой другой источник данных в приложении.

Подсистема ядра Jmix предоставляет `JpaDataStore`, которое хранит xref:entities.adoc#jpa[сущности JPA] в реляционной базе данных. Это основной механизм персистентности в приложениях Jmix. Когда в этом руководстве упоминается хранилище данных, всегда имеется в виду `JpaDataStore`, если явно не указано иное.

Дополнение xref:rest-ds:index.adoc[] предоставляет `RestDataStore`, которое работает с xref:entities.adoc#jpa[DTO сущностями], сопоставленными с xref:rest:index.adoc[] удаленного приложение Jmix. REST хранилище данных имеет некоторые ограничения по сравнению с JPA хранилищем.

[[main]]
== Основное хранилище

При создании нового проекта Jmix в Studio у него есть одно хранилище данных _main_, подключенное к реляционной базе данных. Параметры подключения указаны в следующих свойствах приложения:

[source,properties]
----
include::example$/data-model-ex1/src/main/resources/application.properties[tags=main-data-store]
----

TIP: Используйте интерфейс Studio для настройки подключения к базе данных.

Основной класс приложения содержит соответствующее объявление бина JDBC `DataSource`:

[source,java,indent=0]
----
include::example$/data-model-ex1/src/main/java/com/company/demo/DataModelEx1Application.java[tags=main-data-source]
----

Все сущности JPA по умолчанию связаны с основным хранилищем данных.

[[additional]]
== Дополнительные хранилища

Для работы с несколькими базами данных необходимы дополнительные хранилища данных.

TIP: Определите дополнительные хранилища данных в интерфейсе Studio.

У каждого дополнительного хранилища есть уникальное имя, которое указано в списке свойства приложения `jmix.core.additional-stores`, разделенном запятыми. Параметры подключения к базе данных имеют имя хранилища в качестве префикса. В приведенных ниже примерах настроено дополнительное хранилище `locations`:

[source,properties]
----
include::example$/data-model-ex1/src/main/resources/application.properties[tags=add-data-store]
----

Для каждого дополнительного хранилища Studio создает класс конфигурации Spring и определяет в нем JDBC `DataSource` и другие необходимые бины:

[source,java,indent=0]
----
include::example$/data-model-ex1/src/main/java/com/company/demo/LocationsStoreConfiguration.java[tags=add-data-source]
----

Чтобы связать сущность с дополнительным хранилищем данных, используйте аннотацию `@Store` на классе сущностей:

[source,java,indent=0]
----
include::example$/data-model-ex1/src/main/java/com/company/demo/entity/Country.java[tags=store-ann]
----

TIP: Studio добавляет аннотацию `@Store` при выборе дополнительного хранилища данных для сущности в дизайнере сущностей.

В приведенном выше примере сущность `Country` будет храниться в базе данных, подключенной в качестве хранилища данных `locations`.

[[custom]]
== Нестандартные хранилища

Нестандартное хранилище данных может помочь вам работать с некоторыми сущностями DTO так же, как и с сущностями JPA – с помощью `DataManager`. Если сущность DTO связана с нестандартным хранилищем данных, `DataManager` делегирует операции CRUD этому хранилищу и использует его при поддержке ссылок на DTO из других сущностей.

Давайте рассмотрим процесс создания нестандартного хранилища данных. Представим неперсистентную сущность `Metric` и хранилище в памяти для нее.

. Создайте класс, реализующий интерфейс `DataStore`. Класс должен быть prototype бином Spring. Приведенный ниже пример демонстрирует примитивную реализацию, которая способна хранить в памяти сущности различных типов.
+
[source,java,indent=0]
----
include::example$/data-model-ex1/src/main/java/com/company/demo/store/InMemoryStore.java[tags=custom-store-1;custom-store-2]
----

. Создайте класс, реализующий интерфейс `StoreDescriptor`. Класс должен быть singleton бином Spring и его метод `getBeanName()` должен возвращать имя бина реализации хранилища данных, созданного на предыдущем шаге:
+
[source,java,indent=0]
----
include::example$/data-model-ex1/src/main/java/com/company/demo/store/InMemoryStoreDescriptor.java[tags=custom-store]
----

. Добавьте имя хранилища данных (в данном случае это `inmem`) в свойство `jmix.core.additionalStores`:
+
[source,properties]
----
include::example$/data-model-ex1/src/main/resources/application.properties[tags=custom-data-store-1]
----

. Задайте имя бина `StoreDescriptor` в свойстве `jmix.core.storeDescriptor_<store_name>`:
+
[source,properties]
----
include::example$/data-model-ex1/src/main/resources/application.properties[tags=custom-data-store-2]
----

. Добавьте к сущности аннотацию `@Store`:
+
[source,java,indent=0]
----
include::example$/data-model-ex1/src/main/java/com/company/demo/entity/Metric.java[tags=custom-store]
----
<1> Аннотация `@Store` указывает имя хранилища.
<2> Подробности см. в описании xref:data-model:entities.adoc#jmix-entity[@JmixEntity].

. Теперь вы можете сохранять и загружать сущность с помощью `DataManager`, и он будет  делегировать операции CRUD нестандартному хранилищу данных:
+
[source,java,indent=0]
----
include::example$/data-model-ex1/src/test/java/com/company/demo/EntitiesTest.java[tags=custom-store]
----
+
Кроме того, если другая сущность ссылается на `Metric`, экземпляр `Metric` будет загружаться автоматически при обращении к ссылочному атрибуту.
