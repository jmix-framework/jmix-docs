= 使用 DataManager

对实体进行 CRUD 操作的主要接口是 `DataManager`。基本功能包括通过 ID 或查询语句加载实体关系图、保存实体和删除实体。可以用实体事件监听器在加载和保存特定实体时做一些额外的操作。`DataManager` 中也维护了跨数据库的实体引用，包括 JPA、DTO 和混合实体的实体关系图。

可以在 Spring bean 或界面控制器内注入 `DataManager`，示例：

[source,java,indent=0]
----
include::example$/data-access-ex1/src/main/java/com/company/demo/bean/CustomerService.java[tags=inject-dm]
----

在下面的所有例子中，我们都省略定义的代码并默认 `dataManager` 变量就是 `DataManager`。

[[load]]
== 加载实体

`DataManager` 提供加载实体的流式接口。流式接口的入口是使用 `load()` 方法，该方法可以接收实体类或者 `Id` 参数。

[[load-by-id]]
=== 用 Id 加载实体

下面的方式使用实体的 id 加载实体：

[source,java,indent=0]
----
include::example$/data-access-ex1/src/main/java/com/company/demo/bean/CustomerService.java[tags=load-by-id]
----
<1> 流式加载器 API 的入口。
<2> `id()` 接收 id 值。
<3> `one()` 方法加载实体实例。如果给定的 id 匹配不到实体，该方法会抛出 `IllegalStateException`。

实体标识符还可以使用 `Id<E>` 类指定，该类包含实体类型的信息。代码中就不需要使用实体 id 的具体类型（`UUID`、`Long` 等）了，加载实体的代码也更加简洁：

[source,java,indent=0]
----
include::example$/data-access-ex1/src/main/java/com/company/demo/bean/CustomerService.java[tags=load-by-generic-id]
----

如果给定 id 的实体可能不存在的话，除了用 `one()` 结束流式操作之外，还可以使用 `optional()` 返回 `Optional<E>`。下面的示例中，如果实体不存在，则会创建一个新实体并返回：

[source,java,indent=0]
----
include::example$/data-access-ex1/src/main/java/com/company/demo/bean/CustomerService.java[tags=load-optional]
----
<1> 返回 `Optional<Customer>`。

也可以用 `ids()` 方法接收多个实体 id 加载实体列表，示例：

[source,java,indent=0]
----
include::example$/data-access-ex1/src/main/java/com/company/demo/bean/CustomerService.java[tags=load-by-ids]
----

结果列表中的实体顺序与 id 传入的顺序一致。

[[load-all]]
=== 加载所有实体

下面的方法将所有的实体加载到一个列表中：

[source,java,indent=0]
----
include::example$/data-access-ex1/src/main/java/com/company/demo/bean/CustomerService.java[tags=load-all]
----

CAUTION: 仅当你确定表格中的数据不多时才加载所有实体。否则，请使用 <<load-by-query,查询语句>>、<<load-by-conditions,查询条件>> 以及 <<paging-and-sorting,分页查询>>。

[[load-by-query]]
=== 用查询语句加载实体

当使用关系型数据库时，可以用 https://en.wikibooks.org/wiki/Java_Persistence/JPQL[JPQL^] 查询语句加载实体。参阅 xref:data-access:jpql-extensions.adoc[] 了解 Jmix 中的 JPQL 与 JPA 标准有何不同。还有一点需要注意，`DataManager` 只能执行 "select" 查询语句。

下面的方法使用完整的 JPQL 和两个参数加载实体列表：

[source,java,indent=0]
----
include::example$/data-access-ex1/src/main/java/com/company/demo/bean/CustomerService.java[tags=load-by-full-query]
----

流式加载器接口的 `query()` 方法可以使用完整的或者简写的查询语句。如果使用简写的查询语句，则需要遵守下列规则：

* 可以省略 `"select <alias>"` 语句。

* 如果 `"from"` 语句中只包含单一实体，且不需要一个特殊的别名，则可以省略 `"from <entity> <alias> where"` 语句。此时，实体的默认别名为 `e`。

* 可以用占位参数，然后直接在 `query()` 方法中用额外参数的方式传递参数值。

下面是前一个列子的简写版本：

[source,java,indent=0]
----
include::example$/data-access-ex1/src/main/java/com/company/demo/bean/CustomerService.java[tags=load-by-query]
----

带有 join 语句的复杂查询的省略写法：

[source,java,indent=0]
----
include::example$/data-access-ex1/src/main/java/com/company/demo/bean/OrderService.java[tags=load-by-query]
----

[[load-by-conditions]]
=== 使用 Conditions 加载实体

除了 JPQL 查询语句，还可以直接使用查询条件过滤结果。示例：

[source,java,indent=0]
----
include::example$/data-access-ex1/src/main/java/com/company/demo/bean/CustomerService.java[tags=load-by-conditions]
----
<1> `condition()` 方法接收最外层条件。
<2> `LogicalCondition.and()` 方法使用内部的条件创建一个 AND 条件。
<3> 属性条件比较实体属性和指定的值

如果仅需要单一属性条件，直接将条件传递给 `condition()` 方法即可：

[source,java,indent=0]
----
include::example$/data-access-ex1/src/main/java/com/company/demo/bean/CustomerService.java[tags=load-by-condition]
----

`PropertyCondition` 还可以使用引用实体的属性，示例：

[source,java,indent=0]
----
include::example$/data-access-ex1/src/main/java/com/company/demo/bean/OrderService.java[tags=load-by-condition]
----

[[load-scalars]]
=== 加载纯数值和聚合值

除了实体实例之外，`DataManager` 还能以 xref:data-model:entities.adoc#key-value[key-value 实体] 的形式加载纯数值和聚合值。

`loadValues(String query)` 方法加载由给定查询结果填充的 `KeyValueEntity` 实例的列表。示例：

[source,java,indent=0]
----
include::example$/data-access-ex1/src/main/java/com/company/demo/bean/OrderService.java[tags=load-values]
----
<1> 指定数据所在的数据存储。如果实体在主数据存储，则可以省略该方法。
<2> 指定结果 key-value 实体中的属性名称。属性名的顺序要与查询语句中结果集字段的顺序一致。
<3> 从 key-value 实体属性获取加载的值。

`loadValue(String query, Class valueType)` 方法加载由查询语句指定的单一类型值。示例：

[source,java,indent=0]
----
include::example$/data-access-ex1/src/main/java/com/company/demo/bean/OrderService.java[tags=load-value]
----
<1> 返回值的类型。
<2> 指定数据所在的数据存储。如果实体在主数据存储，则可以省略该方法。

[[load-scalars-limitations]]
==== 局限性

`loadValues()` 和 `loadValue()` 方法有下列限制：

. 查询语句必须是单一指定数据存储的有效 JPQL。只能包含 JPA 实体的持久化属性。

. 不支持 xref:data-model:entities.adoc#cross-data-store-ref[跨数据存储的引用]。

. 这些方法没有在 xref:rest-ds:index.adoc[] 中实现。

[[paging-and-sorting]]
=== 分页和排序

当使用 `all()`、`query()` 或 `condition()` 方法加载实体时，还可以对结果进行排序或分页。

使用 `firstResult()` 和 `maxResults()` 方法进行分页：

[source,java,indent=0]
----
include::example$/data-access-ex1/src/main/java/com/company/demo/bean/CustomerService.java[tags=load-page-by-query]
----

使用 `sort()` 方法对结果排序：

[source,java,indent=0]
----
include::example$/data-access-ex1/src/main/java/com/company/demo/bean/CustomerService.java[tags=load-and-sort]
----

`Sort.by()` 方法中，还可以指定引用实体的属性，示例：

[source,java,indent=0]
----
include::example$/data-access-ex1/src/main/java/com/company/demo/bean/OrderService.java[tags=load-sorted]
----

当用 JPQL 查询时，也可以使用标准的 `order by` 语句：

[source,java,indent=0]
----
include::example$/data-access-ex1/src/main/java/com/company/demo/bean/CustomerService.java[tags=load-by-query-sorted]
----

[[lock]]
=== 使用锁

通过 `lockMode()` 方法可以在数据库层面对 JPA 实体加锁，该方法接收 `jakarta.persistence.LockModeType` 枚举类型值作为参数。下面的示例中，使用了悲观锁，最后形成的 SQL 语句类似：`select ... for update`：

[source,java,indent=0]
----
include::example$/data-access-ex1/src/main/java/com/company/demo/bean/CustomerService.java[tags=using-locks]
----

[[save]]
== 保存实体

用 `save()` 方法保存新建和修改过的实体至数据库。

最简单的形式，该方法接收一个实体实例，返回一个保存了的实例：

[source,java,indent=0]
----
include::example$/data-access-ex1/src/main/java/com/company/demo/bean/CustomerService.java[tags=save]
----

NOTE: 通常传入和返回的实例并不相同。返回的实例可能会受实体事件监听器、数据库触发器或访问控制权限影响。因此，如果需要保存实体后继续处理该实体，则需要使用 `save()` 方法返回的实例。

`save()` 方法可以一次接收多个实例。此时，它返回 `EntitySet` 对象，可以用来获取保存的实例。下面的例子中，我们创建并保存两个相关联的实体，并返回其中一个：

[source,java,indent=0]
----
include::example$/data-access-ex1/src/main/java/com/company/demo/bean/OrderService.java[tags=save-multiple]
----
<1> 保存关联实体。`save()` 方法参数的顺序不重要。
<2> `EntitySet.get()` 方法可以通过源实例获取保存后的实例。

`save()` 方法最强大的形式是能接收 `SaveContext` 对象，这个对象能用来添加多个实例并指定额外的保存参数。下面的例子中，我们用 `SaveContext` 保存实体集合：

[source,java,indent=0]
----
include::example$/data-access-ex1/src/main/java/com/company/demo/bean/OrderService.java[tags=save-context]
----

[[save-performance]]
=== 高性能

在进行保存操作时，有一些技巧可以提高性能。特别是当需要保存大量实体时，这些技巧很有用。

首先，不要一个一个实体调用单独的 `save(entity)` 方法，而是可以将所有实体（数量小于 1000）放在一个事务中保存，如上面所介绍的，将实体添加到 `SaveContext` 后调用 `save(SaveContext)`。

如果不需要返回保存后的实例，可以使用 `SaveContext.setDiscardSaved(true)`。这可以显著提高性能，因为 `DataManager` 不需要从数据库加载保存后的实体了。示例：

[source,java,indent=0]
----
include::example$/data-access-ex1/src/main/java/com/company/demo/bean/OrderService.java[tags=save-discard]
----

如果无需检查当前用户的安全权限，可以使用 `UnconstrainedDataManager` 进一步提高性能。示例：

[source,java,indent=0]
----
include::example$/data-access-ex1/src/main/java/com/company/demo/bean/OrderService.java[tags=save-unconstrained]
----

如果实体数量非常大（比如，大于 1000），则可以通过分批保存的方式提高性能。示例：

[source,java,indent=0]
----
include::example$/data-access-ex1/src/main/java/com/company/demo/bean/OrderService.java[tags=save-batches]
----

可以参考 GitHub 的 https://github.com/jmix-framework/jmix-data-performance-tests[jmix-data-performance-tests^] 项目了解不同保存实体方式的性能比较。项目中测试了 `DataManager`、`EntityManager` 和 `JdbcTemplate` 单条插入以及批量插入的性能对比，并且在 `test\java\com\company\demo` 目录提供了相应的源码。

[[remove]]
== 删除实体

用 `remove()` 方法从数据库删除实体。

最简单的形式，该方法接收一个将要删除的实体实例：

[source,java,indent=0]
----
include::example$/data-access-ex1/src/main/java/com/company/demo/bean/CustomerService.java[tags=remove]
----

`remove()` 方法可以接收多个实例、数组或者集合：

[source,java,indent=0]
----
include::example$/data-access-ex1/src/main/java/com/company/demo/bean/CustomerService.java[tags=remove-list]
----

如果要删除关联实体，那么参数的顺序就很重要了。要先传入依赖其他实体的实体，示例：

[source,java,indent=0]
----
include::example$/data-access-ex1/src/main/java/com/company/demo/bean/OrderService.java[tags=remove-multiple]
----

如果没有实体实例，而只有它的 id，那么可以从 id 构造一个 `Id` 对象并传给 `remove()` 方法：

[source,java,indent=0]
----
include::example$/data-access-ex1/src/main/java/com/company/demo/bean/CustomerService.java[tags=remove-by-id]
----

如需为删除操作设置额外的参数，例如，需要关掉 xref:data-model:soft-deletion.adoc[软删除]，将带有软删除特性的实体完全删除，那么需要用 `save()` 方法，带 `SaveContext` 参数，并将要删除的实体传给 `SaveContext` 的 `removing()` 方法：

[source,java,indent=0]
----
include::example$/data-access-ex1/src/main/java/com/company/demo/bean/OrderService.java[tags=hard-delete]
----

[[transactions]]
== DataManager 中的事务

处理 JPA 实体时，`DataManager` 默认会使用当前的已有的事务，如果无可用的事务，则会创建一个新的事务并提交。

可以按照 xref:transactions.adoc[] 章节的说明使用注解或 `TransactionTemplate` 管理事务。

此外，`DataManager` 还支持控制其内部事务的行为。

当使用流式 API 加载数据时，可以用 `joinTransaction(false)` 方法为当前操作创建并提交一个单独的事务：

[source,java,indent=0]
----
include::example$/data-access-ex1/src/main/java/com/company/demo/bean/CustomerService.java[tags=load-in-separate-transaction]
----

当保存实体时，使用 `SaveContext` 的 `setJoinTransaction(false)` 为当前 context 的操作发起并提交一个单独的事务：

[source,java,indent=0]
----
include::example$/data-access-ex1/src/main/java/com/company/demo/bean/CustomerService.java[tags=save-in-separate-transaction]
----

[[security]]
== DataManager 安全机制

`DataManager` 会执行 xref:security:resource-roles.adoc#entity-policy[实体策略] 检查：

* 如果用户无权创建、更新或删除，则 `save()` 和 `remove()` 方法会抛出 `io.jmix.core.security.AccessDeniedException` 异常。

* 如果用户无权限读取，则 `load()` 方法会返回空结果：`null` 或空列表。这个规则只应用在加载根实体时，不影响子实体的加载。


`DataManager` 也会遵循 xref:security:row-level-roles.adoc#policies[行级策略]。JPQL 策略仅影响对象图中根实体的加载，而谓词策略会影响根实体和所有子实体的加载。

`UnconstrainedDataManager` 接口中的方法与 `DataManager` 相同，但是不会检查安全策略。在代码中可以用来绕过安全检查，示例：

[source,java,indent=0]
----
include::example$/data-access-ex1/src/main/java/com/company/demo/bean/CustomerService.java[tags=unconstrained-dm]
----

关于安全的更多内容请参阅 xref:security:authorization.adoc#data-access-checks[] 部分。
