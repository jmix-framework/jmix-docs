= Репозитории данных

Репозитории данных https://docs.spring.io/spring-data/commons/docs/current/reference/html/#repositories.core-concepts[Spring Data] предоставляют полезную абстракцию для работы с сущностями, особенно для реализации бизнес-логики.

Репозитории данных Jmix построены на базе Spring Data, но внутри используют xref:data-access:data-manager.adoc[DataManager]. Это позволяет использовать удобный интерфейс репозиториев и при этом иметь полную поддержку продвинутых возможностей доступа к данным Jmix, таких как xref:data-access:entity-events.adoc[события сущностей], xref:data-model:entities.adoc#cross-data-store-ref[ссылки между сущностями из разных хранилищ], xref:security:authorization.adoc#data-access-checks[проверки доступа к данным] и т.п.

[TIP]
====
В текущей версии {page-component-display-version} API репозиториев данных Jmix помечен как экспериментальный. В следующем функциональном релизе в него могут быть внесены незначительные изменения и API станет стабильным.
====

[[working-with-data-repositories]]
== Работа с репозиториями данных

Вы можете создать репозиторий данных Jmix двумя способами: используя xref:studio:data-repository-wizard.adoc[Мастер создания репозитория данных] или следуя шагам, описанным ниже.

. Создайте интерфейс, унаследованный от `JmixDataRepository`. Используйте класс сущности и класс идентификатора сущности в качестве параметров типа `JmixDataRepository`. Например:
+
--
[source,java,indent=0]
----
include::example$/data-access-ex1/src/main/java/com/company/demo/repository/CustomerRepository.java[tags=data-repository;data-repository-end]
----
--

. Добавьте аннотацию `@EnableJmixDataRepositories` главному классу приложения или классу конфигурации дополнения:
+
[source,java,indent=0]
----
include::example$/data-access-ex1/src/main/java/com/company/demo/DemoApplication.java[tags=data-repositories]
----
+
Jmix проинициализирует все репозитории данных, расположенные внутри и ниже базового пакета приложения или дополнения. Если требуется более тонкая настройка поиска репозиториев, используйте атрибуты аннотации `basePackages`, `excludeFilters` и `includeFilters`.

. Инжектируйте репозиторий в бины Spring или UI-контроллеры с помощью аннотации `@Autowired`:
+
[source,java,indent=0]
----
include::example$/data-access-ex1/src/test/java/com/company/demo/repository/CustomerRepositoryTest.java[tags=inject]
----

[[jmix-data-repository-features]]
== Особенности JmixDataRepository

Интерфейс `JmixDataRepository` расширяет стандартный интейфейс https://docs.spring.io/spring-data/commons/docs/current/api/org/springframework/data/repository/PagingAndSortingRepository.html[PagingAndSortingRepository^] из Spring Data. Он предоставляет несколько собственных методов, учитывающих специфику Jmix:

* Методы загрузки, такие как `findById()` или `findAll()`, могут принимать xref:data-access:fetching.adoc#fetch-plan[фетч-план].
* Метод `create()` xref:data-model:entities.adoc#instantiation[создает] новый экземпляр сущности.
* Метод `getById()` с обязательным результатом загружает сущность по идентификатору и выбрасывает исключение, если сущность не найдена.
* Метод `getDataManager()` возвращает `DataManager` для использования в методах по умолчанию.
* Метод `save()` сохраняет предоставленную сущность и возвращает сохраненный экземпляр, загруженный с указанным планом выборки. Метод принимает сущность для сохранения и план выборки, который будет применен при перезагрузке сохраненной сущности. Сущность не может быть `null`, а план выборки должен быть применим к сущности.

[[JmixDataRepositoryContext]]
Методы загрузки репозиториев, унаследованных от `JmixDataRepository`, теперь поддерживают дополнительный аргумент типа `JmixDataRepositoryContext`. Это позволяет передавать параметры фильтрации, пейджинга и сортировки, собранные в объект `LoadContext` из UI-компонентов. В результате все функции компонентов `genericFilter`, `simplePagination` и `dataGrid` будут полноценно работать с репозиториями данных.

[[ApplyConstraints]]
Вы можете применить аннотацию `io.jmix.core.repository.ApplyConstraints` к своему репозиторию данных. Если значение аннотации равно `false`, репозиторий использует `UnconstrainedDataManager` вместо `DataManager`. Значение аннотации по умолчанию - `true`.

Аннотация `@ApplyConstraints` может быть использована не только для всего класса, но и для отдельных методов, чтобы игнорировать или, наоборот, включить ограничения только для них.

[source,java,indent=0]
----
include::example$/data-access-ex1/src/main/java/com/company/demo/repository/OrderRepository.java[tags=ApplyConstraints]
----

В приведенном выше примере `@ApplyConstraints(false)` применяется только к двум методам, и для них будет использоваться `UnconstrainedDataManager`.

В приведенном ниже примере ограничения отключены для всего класса, но включены точечно для отдельных методов:

[source,java,indent=0]
----
include::example$/data-access-ex1/src/main/java/com/company/demo/repository/ProductRepository.java[tags=ApplyConstraints]
----

Методы `findAll()` и `searchByIdNotNull()` будут использовать обычный `DataManager`, в то время как все остальные методы будут использовать `UnconstrainedDataManager`.

Следующие аннотации можно использовать на кастомных методах запросов:

* `@io.jmix.core.repository.Query` задает строку JPQL аналогично аннотации `@Query` в Spring Data JPA.
* `@io.jmix.core.repository.FetchPlan` задает фетч-план для загрузки данных.
* `@io.jmix.core.repository.QueryHints` и `@jakarta.persistence.QueryHint` позволяют вам указать хинты для xref:data-model:soft-deletion.adoc#turn-soft-deletion-off[отключения мягкого удаления] и xref:cache.adoc#query-cache[использования кэша запросов].

[NOTE]
====
Если имя метода/запроса и параметры метода имеют разные значения для плана выборки и хинтов, то окончательные значения выбираются на основе приоритета, от самого высокого к самому низкому.

*FetchPlan:*

. Параметр `FetchPlan`. План выборки, явно указанный в качестве параметра метода, имеет наивысший приоритет.
. Параметр `JmixDataRepositoryContext#fetchPlan`.
. Значение аннотации `@FetchPlan`.

*Hints:*

. Параметр `JmixDataRepositoryContext`.
. Значение аннотации `@QueryHints`.

Для хинтов с одинаковым ключом значение из источника с более высоким приоритетом переопределит значение из источника с более низким приоритетом. Разные ключи будут объединены.
====

[[query-method-examples]]
== Примеры методов запросов

Репозитории данных Jmix поддерживают стандартную возможность Spring Data выводить запрос из имени метода, например:

[source,java,indent=0]
----
include::example$/data-access-ex1/src/main/java/com/company/demo/repository/CustomerRepository.java[tags=name-based-method]
----

Аналогично Spring Data JPA, JPQL-запрос можно явно задать с помощью аннотации `@io.jmix.core.repository.Query`:

[source,java,indent=0]
----
include::example$/data-access-ex1/src/main/java/com/company/demo/repository/CustomerRepository.java[tags=query]
----

Методы запросов могут принимать объект `Pageable` для постраничной загрузки и сортировки:

[source,java,indent=0]
----
include::example$/data-access-ex1/src/main/java/com/company/demo/repository/CustomerRepository.java[tags=paging]
----

Другой специально обрабатываемый параметр, который можно использовать в методах запросов - xref:data-access:fetching.adoc#fetch-plan[фетч-план]:

[source,java,indent=0]
----
include::example$/data-access-ex1/src/main/java/com/company/demo/repository/CustomerRepository.java[tags=fetch-plan]
----

Разделяемый фетч-план можно задавать по имени в аннотации `@io.jmix.core.repository.FetchPlan`:

[source,java,indent=0]
----
include::example$/data-access-ex1/src/main/java/com/company/demo/repository/CustomerRepository2.java[tags=fetch-plan]
----

xref:cache.adoc#query-cache[Кэшируемый] запрос:

[source,java,indent=0]
----
include::example$/data-access-ex1/src/main/java/com/company/demo/repository/CustomerRepository3.java[tags=cacheable]
----