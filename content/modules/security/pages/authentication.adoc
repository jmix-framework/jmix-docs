= 认证

认证是验证与系统交互的用户或进程的身份的过程。例如，系统可以通过用户名和密码对用户进行认证。对已经认证的用户，系统可以执行 xref:authorization.adoc[授权]，检查用户对特定资源的权限。

Jmix 直接使用 Spring Security {spring-security-doc}/servlet/authentication/index.html[servlet 认证^]，因此，如果对这个框架比较熟悉，可以很容易地扩展或覆盖 Jmix 提供的内置标准认证机制。

[[current]]
== 当前用户

如需确定当前的认证用户，请使用 `CurrentAuthentication` bean。有以下方法：

* `getUser()` 以 {spring-security-api}/org/springframework/security/core/userdetails/UserDetails.html[UserDetails^] 返回当前认证用户。可以将其转换为项目中定义的 xref:users.adoc#entity[用户实体]。

* `getAuthentication()` 返回当前线程中关联的 {spring-security-api}/org/springframework/security/core/Authentication.html[Authentication^] 对象。`Authentication` 对象中带有用户角色的名称信息。
+
Jmix 使用 Spring Security 的 https://docs.spring.io/spring-security/site/docs/current/api/org/springframework/security/core/authority/SimpleGrantedAuthority.html[SimpleGrantedAuthority^] 类表示用户的角色。这个类用单一字符串表示一个角色。字符串的格式为：
+
--
** 对于 xref:resource-roles.adoc[资源角色]：`ROLE_<role-code>`，例如，`ROLE_system-full-access`。
** 对于 xref:row-level-roles.adoc[行级角色]：`ROW_LEVEL_ROLE_<role-code>`，例如，`ROW_LEVEL_ROLE_my-role`。
--
+
如需从角色编码创建授权的 Java 类和内容，可以使用 `RoleGrantedAuthorityUtils` 类。
+
[TIP]
====
通过标准的 Spring 机制可以自定义资源角色的前缀，需要配置 `org.springframework.security.config.core.GrantedAuthorityDefaults` bean。

类似地，行级角色的前缀可以通过 `jmix.security.default-row-level-role-prefix` 应用程序属性修改。
====

* `getLocale()` 和 `getTimeZone()` 返回当前用户的语言环境和时区。

* `isSet()` 如果当前线程已通过认证，则返回 `true`，即已经包含用户的相关信息。否则，上面的 `getUser()`、`getLocale()` 和 `getTimeZone()` 方法将抛出 `IllegalStateException`。

下面是获取当前用户信息的示例：

[source,java,indent=0]
----
include::example$/security-ex1/src/main/java/com/company/demo/view/authtest/AuthTestView.java[tags=current-auth]
----

[NOTE]
====
`CurrentAuthentication` 只是 {spring-security-api}/org/springframework/security/core/context/SecurityContextHolder.html[SecurityContextHolder^] 的包装器，因此能与所有 Spring Security 机制兼容。

例如，可以使用 `DelegatingSecurityContextRunnable` 为新线程设置认证信息，参阅 {spring-security-doc}/servlet/integrations/concurrency.html[Spring Security 文档^]。
====

[[client]]
== 客户端认证

后端 Jmix 应用程序可以支持不同的客户端，例如，Jmix UI 或 REST API。每个客户端都有自己的标准认证机制，例如，UI 登录视图和 xref:rest:access-control.adoc[REST 访问 token]。

[[custom-password-validation]]
=== 自定义密码验证

如需实现自定义密码验证，需要创建一个或多个 bean，实现接口 `PasswordValidator`，示例：

[source,java,indent=0]
----
include::example$/security-ex1/src/main/java/com/company/demo/security/MyPasswordValidator.java[]
----

在 `ChangePassword - 修改密码` 操作的对话框会自动使用所有的密码验证 bean。

如需在用户详情视图添加自定义密码验证，可以使用 `PasswordValidation` 辅助 bean：

[source,java,indent=0]
----
include::example$/security-ex1/src/main/java/com/company/demo/view/user/UserDetailView.java[tags=password-validation]
----

[[brute-force-protection]]
=== 防暴力破解

框架具有防止暴力破解密码的机制。

使用 <<jmix.security.bruteforceprotection.enabled,jmix.security.bruteforceprotection.enabled>> 应用程序属性启用该保护机制。如果启用了保护，则在多次尝试登录失败后，在一段时间内阻止相同用户名和 IP 地址再次登录。相同用户名和 IP 地址的最大尝试登录次数由 <<jmix.security.bruteforceprotection.max-login-attempts-number,jmix.security.bruteforceprotection.max-login-attempts-number>> 应用属性定义。阻止时长由 <<jmix.security.bruteforceprotection.block-interval,jmix.security.bruteforceprotection.block-interval>> 应用程序属性定义，单位为秒。

[[jmix.security.bruteforceprotection.enabled]]
* `jmix.security.bruteforceprotection.enabled`
+
启用防止暴力破解密码的机制。默认值：`false`。

[[jmix.security.bruteforceprotection.block-interval]]
* `jmix.security.bruteforceprotection.block-interval`
+
如果 <<jmix.security.bruteforceprotection.enabled,jmix.security.bruteforceprotection.enabled>> 属性启用，定义超过最大失败登录次数后阻止再次登录的时间（单位为秒）。默认值：`60 秒`。

[[jmix.security.bruteforceprotection.max-login-attempts-number]]
* `jmix.security.bruteforceprotection.max-login-attempts-number`
+
如果 <<jmix.security.bruteforceprotection.enabled,jmix.security.bruteforceprotection.enabled>> 属性启用开，定义相同用户名和 IP 地址的最大失败尝试登录次数。默认值：`5`。

[[session-attributes]]
=== 会话属性

如需在同一用户的不同请求中共享值，请使用 `SessionData` bean。其中包含读写当前用户会话中命名值的方法。

可以直接在 UI 视图注入 `SessionData` bean：

[source,java,indent=0]
----
include::example$/security-ex1/src/main/java/com/company/demo/view/customer/CustomerListView.java[tags=session-data]
----

在 singleton bean 中，通过 `org.springframework.beans.factory.ObjectProvider` 使用 `SessionData`：

[source,java,indent=0]
----
include::example$/security-ex1/src/main/java/com/company/demo/service/CustomerService.java[tags=session-data]
----

TIP: 会话属性也可以用在 xref:data-access:jpql-extensions.adoc#session-and-user-attributes[JPQL 查询语句] 中。

当处理 UI 请求时，共享值保存在 HTTP 会话中。

// todo jmix-session
// 如需在使用同一个 token 的 REST API 请求之间共享会话属性，请在 `build.gradle` 添加下列依赖：

// [source,groovy]
// ----
// implementation 'io.jmix.sessions:jmix-sessions-starter'
// ----

[[system]]
== 系统认证

如果执行线程由内部调度程序启动或处理来自 JMX 接口的请求，则无法对其进行认证。然而此时，业务逻辑或数据访问代码通常需要知道当前使用系统的用户信息，以便进行日志记录或授权。

如需将当前执行线程与用户临时关联，请使用 `SystemAuthenticator` bean。有以下方法：

* `withSystem()` - 接收一个 lambda 方法，并以 xref:users.adoc#built-in[system] 用户执行。

* `withUser()` - 接收一个普通用户的用户名和一个 lambda 方法，并以给定用户的权限执行。

下面是对一个 MBean 操作进行认证的示例：

[source,java,indent=0]
----
include::example$/security-ex1/src/main/java/com/company/demo/mbean/SettingsManagementFacade.java[tags=system-authenticator;current-authentication;system-auth-code]
----

也可以使用 `@Authenticated` 注解对整个 bean 方法进行认证，并使用 `system` 用户执行。示例：

[source,java,indent=0]
----
include::example$/security-ex1/src/main/java/com/company/demo/mbean/SettingsManagementFacade.java[tags=current-authentication;system-auth-ann]
----

[[authentication-events]]
== 认证事件

Spring 框架会发送与认证相关的特定应用程序事件。

TIP: Studio 可以帮助你生成认证事件的监听器。在 *Jmix* 工具窗口中单击 *New (+) -> Event Listener*，然后在对话框中选择 *Authentication Event* 即可。

下面是处理认证事件的示例。

[source,java,indent=0]
----
include::example$/security-ex1/src/main/java/com/company/demo/security/AuthenticationEventListener.java[tags=class]
----

<1> `InteractiveAuthenticationSuccessEvent` 当用户通过 UI 或 REST API 登录时发送。
<2> `InteractiveAuthenticationSuccessEvent` 包含用户实体。
<3> `AuthenticationSuccessEvent` 任何认证（包括 <<system,系统认证>>）成功时发送。
+
CAUTION: 在该事件监听器中，不要使用 `CurrentAuthentication` bean 获取 <<current,当前用户>>。这个事件在认证过程的很早阶段就发出，因此，获取当前用户时可能会抛出异常或返回一个之前认证的对象。所以，获取当前用户只能通过 `AuthenticationSuccessEvent` 对象。

<4> `AuthenticationSuccessEvent` 包含用户实体。
<5> `AbstractAuthenticationFailureEvent` 当尝试认证失败时发送，例如，由于凭证无效。
<6> `AbstractAuthenticationFailureEvent` 仅包含用于认证的用户名。
<7> `LogoutSuccessEvent` 当用户登出时发送。
<8> `LogoutSuccessEvent` 包含用户实体。
