= Аутентификация

Аутентификация – это процесс проверки личности пользователя или процесса, который взаимодействует с системой. Например, система может аутентифицировать пользователей по их имени и паролю. Для аутентифицированных пользователей система может выполнить xref:authorization.adoc[авторизацию], которая представляет собой проверку разрешений для определенного ресурса.

Jmix напрямую использует https://docs.spring.io/spring-security/reference/servlet/authentication/index.html[Servlet аутентификацию^] Spring Security, поэтому если вы знакомы с этой платформой, то вы можете легко расширить или переопределить стандартный механизм аутентификации, предоставляемый Jmix "из коробки".

[[current]]
== Текущий пользователь

Чтобы определить, кто в данный момент аутентифицирован, используйте бин `CurrentAuthentication`. Он имеет следующие методы:

* `getUser()` возвращает текущего аутентифицированного пользователя как https://docs.spring.io/spring-security/site/docs/current/api/org/springframework/security/core/userdetails/UserDetails.html[UserDetails^]. Его можно привести к классу xref:users.adoc#entity[пользователя], определенному в проекте.

* `getAuthentication()` возвращает объект https://docs.spring.io/spring-security/site/docs/current/api/org/springframework/security/core/Authentication.html[Authentication^], установленный в текущем потоке выполнения. Его можно использовать, чтобы получить коллекцию https://docs.spring.io/spring-security/site/docs/current/api/org/springframework/security/core/GrantedAuthority.html[полномочий^] текущего пользователя. В стандартной реализации безопасности Jmix эта коллекция содержит объекты полномочий для каждой xref:resource-roles.adoc[ресурсной] и xref:row-level-roles.adoc[row-level] роли, назначенной пользователю.

* `getLocale()` и `getTimeZone()` возвращают локаль и часовой пояс текущего пользователя.

* `isSet()` возвращает значение true, если текущий поток выполнения аутентифицирован, то есть содержит информацию о пользователе. Если это не так, методы `getUser()`, `getLocale()` и `getTimeZone()`, описанные выше, выбросят исключение `IllegalStateException`.

Ниже приведен пример получения информации о текущем пользователе:

[source,java,indent=0]
----
include::example$/ex1/src/main/java/security/ex1/screen/auth/AuthTestScreen.java[tags=current-auth]
----

NOTE: `CurrentAuthentication` – это просто обёртка вокруг https://docs.spring.io/spring-security/site/docs/current/api/org/springframework/security/core/context/SecurityContextHolder.html[SecurityContextHolder^], поэтому он полностью совместим со всеми механизмами Spring Security.

[[client]]
== Аутентификация клиента

У бэкенда приложения Jmix могут быть разные клиенты, например, UI, GraphQL, или REST API. Каждый клиент имеет свой собственный стандартный механизм аутентификации, например:

* xref:backoffice-ui:screens/root-screens.adoc#login-screen[Окно входа] UI
* xref:rest:security/authentication.adoc[Аутентификация] REST

[[brute-force-protection]]
=== Защита от взлома методом перебора

В фреймворке есть механизм защиты от взлома паролей методом перебора, которая обеспечивается свойством приложения <<jmix-security-bruteforceprotection-enabled,jmix.security.bruteforceprotection.enabled>>. Если она включена, комбинация логина пользователя и IP-адреса блокируется на определенный промежуток времени в случае нескольких неудачных попыток входа в систему. Максимальное количество попыток определяется свойством приложения <<jmix-security-bruteforceprotection-maxLoginAttemptsNumber,jmix.security.bruteforceprotection.maxLoginAttemptsNumber>>. Интервал блокировки в секундах определяется свойством приложения <<jmix-security-bruteforceprotection-blockInterval,jmix.security.bruteforceprotection.blockInterval>>.

[[jmix-security-bruteforceprotection-enabled]]
* `jmix.security.bruteforceprotection.enabled`
+
Включает механизм защиты от взлома пароля методом перебора. Значение по умолчанию: `false`.

[[jmix-security-bruteforceprotection-blockInterval]]
* `jmix.security.bruteforceprotection.blockInterval`
+
Определяет интервал блокировки в секундах после превышения максимального количества неудачных попыток входа в систему, если включено свойство <<jmix-security-bruteforceprotection-enabled,jmix.security.bruteforceprotection.enabled>>. Значение по умолчанию: `60 seconds`.

[[jmix-security-bruteforceprotection-maxLoginAttemptsNumber]]
* `jmix.security.bruteforceprotection.maxLoginAttemptsNumber`
+
Определяет максимальное количество неудачных попыток входа в систему для комбинации логина пользователя и IP-адреса, если включено свойство <<jmix-security-bruteforceprotection-enabled,jmix.security.bruteforceprotection.enabled>>. Значение по умолчанию: `5`.

[[system]]
== Системная аутентификация

Поток выполнения может быть не аутентифицирован, если был запущен внутренним планировщиком или обрабатывает запрос из JMX-интерфейса. Однако обычно бизнес-логике или коду доступа к данным для журналирования или авторизации требуется информация о том, кто в данный момент работает с системой.

Чтобы временно связать текущий поток выполнения с пользователем, используйте бин `SystemAuthenticator`. Он имеет следующие методы:

* `withSystem()` - принимает lambda-выражение и выполняет его от имени xref:users.adoc#built-in[системного] пользователя.

* `withUser()` - принимает имя обычного пользователя приложения и lambda-выражение и выполняет его от имени данного пользователя с соответствующими разрешениями.

Ниже приведен пример аутентификации операции MBean:

[source,java,indent=0]
----
include::example$/ex1/src/main/java/security/ex1/mbean/SettingsManagementFacade.java[tags=system-authenticator;current-authentication;system-auth-code]
----

Также можно использовать аннотацию `@Authenticated` для аутентификации всего метода бина, как выполняемого пользователем `system`. Например:

[source,java,indent=0]
----
include::example$/ex1/src/main/java/security/ex1/mbean/SettingsManagementFacade.java[tags=current-authentication;system-auth-ann]
----

[[authentication-events]]
== События аутентификации

Фреймворк Spring посылает определенные события приложения, связанные с аутентификацией.

TIP: Studio может помочь вам создать слушателей событий аутентификации. Нажмите *New (+) -> Event Listener* в окне инструментов *Jmix* и выберите *Authentication Event* в диалоговом окне.

Ниже приведен пример обработки событий аутентификации.

[source,java,indent=0]
----
include::example$/ex1/src/main/java/security/ex1/security/AuthenticationEventListener.java[tags=class]
----

<1> `InteractiveAuthenticationSuccessEvent` посылается, когда пользователь входит в систему через UI или REST API.
<2> `InteractiveAuthenticationSuccessEvent` содержит сущность пользователя.
<3> `AuthenticationSuccessEvent` отправляется при любой успешной аутентификации, включая <<system,системную>>.
<4> `InteractiveAuthenticationSuccessEvent` содержит сущность пользователя.
<5> `AbstractAuthenticationFailureEvent` посылается, если попытка аутентификации не удалась, например, из-за ввода неверных учетных данных.
<6> `AbstractAuthenticationFailureEvent` содержит только имя пользователя, указанное при аутентификации.
<7> `LogoutSuccessEvent` посылается при выходе пользователя из системы.
<8> `LogoutSuccessEvent` содержит сущность пользователя.
