= Аутентификация

Аутентификация – это процесс проверки личности пользователя или процесса, который взаимодействует с системой. Например, система может аутентифицировать пользователей по их имени и паролю. Для аутентифицированных пользователей система может выполнить xref:authorization.adoc[авторизацию], которая представляет собой проверку разрешений для определенного ресурса.

Jmix напрямую использует {spring-security-doc}/servlet/authentication/index.html[Servlet аутентификацию^] Spring Security, поэтому если вы знакомы с этой платформой, то вы можете легко расширить или переопределить стандартный механизм аутентификации, предоставляемый Jmix "из коробки".

[[current]]
== Текущий пользователь

Чтобы определить, кто в данный момент аутентифицирован, используйте бин `CurrentAuthentication`. Он имеет следующие методы:

* `getUser()` возвращает текущего аутентифицированного пользователя как {spring-security-api}/org/springframework/security/core/userdetails/UserDetails.html[UserDetails^]. Его можно привести к классу xref:users.adoc#entity[пользователя], определенному в проекте.

* `getAuthentication()` возвращает объект {spring-security-api}/org/springframework/security/core/Authentication.html[Authentication^], связанный с текущим потоком выполнения. Объект `Authentication` хранит имена ролей пользователя.
+
Jmix использует класс Spring Security https://docs.spring.io/spring-security/site/docs/current/api/org/springframework/security/core/authority/SimpleGrantedAuthority.html[SimpleGrantedAuthority^] для представления ролей пользователей. Этот класс фактически хранит одну строку, представляющую роль. Формат этой строки:
+
--
** Для xref:resource-roles.adoc[ресурсных] ролей: `ROLE_<role-code>`, например, `ROLE_system-full-access`.
** Для ролей xref:row-level-roles.adoc[уровня строк]: `ROW_LEVEL_ROLE_<role-code>`, например, `ROW_LEVEL_ROLE_my-role`.
--
+
Granted authorities нужного Java-класса и содержания могут быть созданы из кодов ролей с использованием класса `RoleGrantedAuthorityUtils`.
+
[TIP]
====
Вы можете настроить префикс для полномочий ресурсных ролей, используя стандартный механизм Spring, путем конфигурирования бина `org.springframework.security.config.core.GrantedAuthorityDefaults`.

Аналогично, вы можете скорректировать префикс для полномочий ролей уровня строк, используя свойство приложения `jmix.security.default-row-level-role-prefix`.
====
* `getLocale()` и `getTimeZone()` возвращают локаль и часовой пояс текущего пользователя.

* `isSet()` возвращает значение `true`, если текущий поток выполнения аутентифицирован, то есть содержит информацию о пользователе. Если это не так, методы `getUser()`, `getLocale()` и `getTimeZone()`, описанные выше, выбросят исключение `IllegalStateException`.

Ниже приведен пример получения информации о текущем пользователе:

[source,java,indent=0]
----
include::example$/security-ex1/src/main/java/com/company/demo/view/authtest/AuthTestView.java[tags=current-auth]
----

[NOTE]
====
`CurrentAuthentication` – это просто обёртка вокруг {spring-security-api}/org/springframework/security/core/context/SecurityContextHolder.html[SecurityContextHolder^], поэтому он полностью совместим со всеми механизмами Spring Security.

Например, вы можете использовать `DelegatingSecurityContextRunnable` для передачи контекста аутентификации в новые потоки как описано в {spring-security-doc}/servlet/integrations/concurrency.html[документации Spring Security^].
====

[[client]]
== Аутентификация клиента

У бэкенда приложения Jmix могут быть разные клиенты, например, Jmix UI или REST API. Каждый клиент имеет свой собственный стандартный механизм аутентификации, такой как окно логина UI или xref:rest:access-control.adoc[токен доступа REST].

[[custom-password-validation]]
=== Собственная валидация паролей

Чтобы реализовать собственную валидацию паролей в приложении, достаточно создать бин (или несколько бинов), реализующий интерфейс `PasswordValidator`. Например:

[source,java,indent=0]
----
include::example$/security-ex1/src/main/java/com/company/demo/security/MyPasswordValidator.java[]
----

Все валидаторы будут автоматически использованы в диалоге действия ChangePassword.

Для добавления кастомной валидации в экран деталей сущности User, используйте бин-помощник `PasswordValidation`:

[source,java,indent=0]
----
include::example$/security-ex1/src/main/java/com/company/demo/view/user/UserDetailView.java[tags=password-validation]
----

[[brute-force-protection]]
=== Защита от взлома методом перебора

В фреймворке есть механизм защиты от взлома паролей методом перебора, которая обеспечивается свойством приложения <<jmix.security.bruteforceprotection.enabled,jmix.security.bruteforceprotection.enabled>>. Если она включена, комбинация логина пользователя и IP-адреса блокируется на определенный промежуток времени в случае нескольких неудачных попыток входа в систему. Максимальное количество попыток определяется свойством приложения <<jmix.security.bruteforceprotection.max-login-attempts-number,jmix.security.bruteforceprotection.max-login-attempts-number>>. Интервал блокировки в секундах определяется свойством приложения <<jmix.security.bruteforceprotection.block-interval,jmix.security.bruteforceprotection.block-interval>>.

[[jmix.security.bruteforceprotection.enabled]]
* `jmix.security.bruteforceprotection.enabled`
+
Включает механизм защиты от взлома пароля методом перебора. Значение по умолчанию: `false`.

[[jmix.security.bruteforceprotection.block-interval]]
* `jmix.security.bruteforceprotection.block-interval`
+
Определяет интервал блокировки в секундах после превышения максимального количества неудачных попыток входа в систему, если включено свойство <<jmix.security.bruteforceprotection.enabled,jmix.security.bruteforceprotection.enabled>>. Значение по умолчанию: `60 seconds`.

[[jmix.security.bruteforceprotection.max-login-attempts-number]]
* `jmix.security.bruteforceprotection.max-login-attempts-number`
+
Определяет максимальное количество неудачных попыток входа в систему для комбинации логина пользователя и IP-адреса, если включено свойство <<jmix.security.bruteforceprotection.enabled,jmix.security.bruteforceprotection.enabled>>. Значение по умолчанию: `5`.

[[session-attributes]]
=== Атрибуты сессии

Если вам необходимо использовать некоторые значения в нескольких запросах от одного и того же подключенного пользователя, используйте бин `SessionData`. В нем есть методы для чтения и записи именованных значений, хранящихся в текущей сессии пользователя.

Бин `SessionData` можно инжектировать напрямую в экраны UI:

[source,java,indent=0]
----
include::example$/security-ex1/src/main/java/com/company/demo/view/customer/CustomerListView.java[tags=session-data]
----

В singleton-бине используйте `SessionData` через `org.springframework.beans.factory.ObjectProvider`:

[source,java,indent=0]
----
include::example$/security-ex1/src/main/java/com/company/demo/service/CustomerService.java[tags=session-data]
----

TIP: Атрибуты сессии также можно использовать в xref:data-access:jpql-extensions.adoc#session-and-user-attributes[запросах JPQL].

При обработке запросов UI общие значения сохраняются в сессии HTTP.

// todo jmix-session
// Для совместного использования атрибутов сессии в запросах REST API, аутентифицированных с помощью одного и того же токена, добавьте следующую зависимость в `build.gradle`:
//
// [source,groovy]
// ----
// implementation 'io.jmix.sessions:jmix-sessions-starter'
// ----

[[system]]
== Системная аутентификация

Поток выполнения может быть не аутентифицирован, если был запущен внутренним планировщиком или обрабатывает запрос из JMX-интерфейса. Однако обычно бизнес-логике или коду доступа к данным для журналирования или авторизации требуется информация о том, кто в данный момент работает с системой.

Чтобы временно связать текущий поток выполнения с пользователем, используйте бин `SystemAuthenticator`. Он имеет следующие методы:

* `withSystem()` - принимает lambda-выражение и выполняет его от имени xref:users.adoc#built-in[системного] пользователя.

* `withUser()` - принимает имя обычного пользователя приложения и lambda-выражение и выполняет его от имени данного пользователя с соответствующими разрешениями.

Ниже приведен пример аутентификации операции MBean:

[source,java,indent=0]
----
include::example$/security-ex1/src/main/java/com/company/demo/mbean/SettingsManagementFacade.java[tags=system-authenticator;current-authentication;system-auth-code]
----

Также можно использовать аннотацию `@Authenticated` для аутентификации всего метода бина, как выполняемого пользователем `system`. Например:

[source,java,indent=0]
----
include::example$/security-ex1/src/main/java/com/company/demo/mbean/SettingsManagementFacade.java[tags=current-authentication;system-auth-ann]
----

[[authentication-events]]
== События аутентификации

Фреймворк Spring посылает определенные события приложения, связанные с аутентификацией.

TIP: Studio может помочь вам создать слушателей событий аутентификации. Нажмите *New (+) -> Event Listener* в окне инструментов *Jmix* и выберите *Authentication Event* в диалоговом окне.

Ниже приведен пример обработки событий аутентификации.

[source,java,indent=0]
----
include::example$/security-ex1/src/main/java/com/company/demo/security/AuthenticationEventListener.java[tags=class]
----

<1> `InteractiveAuthenticationSuccessEvent` посылается, когда пользователь входит в систему через UI или REST API.
<2> `InteractiveAuthenticationSuccessEvent` содержит сущность пользователя.
<3> `AuthenticationSuccessEvent` отправляется при любой успешной аутентификации, включая <<system,системную>>.
+
CAUTION: Не используйте бин `CurrentAuthentication` для получения <<current,текущего пользователя>> в этом слушателе. Данное событие отправляется слишком рано в процессе аутентификации, из-за чего бин вызовет исключение или вернет предыдущий объект аутентификации. Вместо этого получайте текущего пользователя из объекта `AuthenticationSuccessEvent`.

<4> `AuthenticationSuccessEvent` содержит сущность пользователя.
<5> `AbstractAuthenticationFailureEvent` посылается, если попытка аутентификации не удалась, например, из-за ввода неверных учетных данных.
<6> `AbstractAuthenticationFailureEvent` содержит только имя пользователя, указанное при аутентификации.
<7> `LogoutSuccessEvent` посылается при выходе пользователя из системы.
<8> `LogoutSuccessEvent` содержит сущность пользователя.
