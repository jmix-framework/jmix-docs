= Кастомные эндпойнты

Запросы к приложению Jmix защищаются фреймворком Spring Security. В этом разделе объясняется, как настроить доступ к кастомным эндпойнтам приложения.

[[general-information]]
== Общие сведения

Для глубокого понимания работы endpoint security, прочитайте соответствующие разделы документации Spring Security:

* {spring-security-doc}/servlet/architecture.html[High-level architecture within Servlet-based applications^]
* {spring-security-doc}/servlet/authorization/authorize-http-requests.html[Authorize HttpServletRequests^]

Spring Security использует специальные бины типа {spring-security-doc}/servlet/architecture.html#servlet-securityfilterchain[SecurityFilterChain^] для определения того, какие URL должны быть защищены. Каждый `SecurityFilterChain` конфигурируется с помощью билдера {spring-security-doc}/servlet/configuration/java.html#jc-httpsecurity[HttpSecurity^]. Приложение может иметь несколько бинов `SecurityFilterChain`. В этом случае очень важно указать их правильный порядок. См. раздел {spring-security-doc}/servlet/configuration/java.html#_multiple_httpsecurity_instances[Multiple HttpSecurity Instances^] в документации Spring Security для информации о настройке нескольких объектов `HttpSecurity`.

Каждое приложение Jmix по умолчанию содержит конфигурацию безопасности, которая расширяет класс {vaadin-docs}/security/enabling-security#security-configuration-class[VaadinWebSecurity^]. Эта конфигурация настраивает доступ к внутренним эндпойнтам Vaadin и передает все запросы на авторизацию механизмам Jmix и Vaadin (предоставляет доступ к экранам с помощью аннотации на классе экрана или анализа ресурсных ролей пользователя). `SecurityFilterChain`, созданный этой конфигурацией, всегда имеет наименьший приоритет и всегда вызывается последним.

Дополнения, такие как xref:oidc:index.adoc[OpenID Connect] или xref:authorization-server:index.adoc[Authorization Server], добавляют свои бины `SecurityFilterChain`, которые защищают эндпойнты авторизационного или ресурсного сервера. Эти бины всегда вызываются до тех, которые предоставлены модулем UI.

[[custom-endpoints-security]]
== Безопасность кастомных эндпойнтов

Для определения кастомных правил безопасности для эндпойнтов объявите новый бин `SecurityFilterChain`. Важно, чтобы порядок этого бина был меньше, чем у бинов `SecurityFilterChain`, предоставленных фреймворком Jmix.

Вы можете найти значения порядка, используемые Jmix, в интерфейсе `JmixSecurityFilterChainOrder`. Практическое правило — использовать `JmixSecurityFilterChainOrder.CUSTOM`, `JmixSecurityFilterChainOrder.CUSTOM - 10` и аналогичные значения для своих фильтров безопасности.

Пример простого бина `SecurityFilterChain` может выглядеть следующим образом:

[source,java,indent=0]
----
include::example$/security-ex1/src/main/java/com/company/demo/security/api/SimplePublicSecurityConfiguration.java[tags=public-filter-chain]
----

Данная конфигурация предоставляет доступ к всем запросам для эндпойнтов, соответствующих шаблону `/public/**`.

[[examples]]
=== Примеры

[[public-endpoints-example]]
==== Публичные эндпойнты

Допустим у вас есть контроллер с двумя методами, и вы хотите, чтобы эти методы были доступны для любого пользователя без аутентификации.

[source,java,indent=0]
----
include::example$/security-ex1/src/main/java/com/company/demo/controller/GreetingController.java[tags=whole-class]
----

Доступ к публичным эндпойнтам можно настроить с помощью следующей конфигурации:

[source,java,indent=0]
----
include::example$/security-ex1/src/main/java/com/company/demo/security/api/AnonymousControllerSecurityConfiguration.java[tags=whole-class]
----
<1> `JmixSecurityFilterChainOrder.CUSTOM` — порядок меньше любого другого порядка безопасности фильтра Jmix.
<2> {spring-security-doc}/servlet/authorization/authorize-http-requests.html#security-matchers[securityMatcher()^] используется для определения, должен ли быть применен `HttpSecurity` к запросу. Matcher запроса из примера будет соответствовать запросам с URL, которые соответствуют шаблону `/greeting/**`. Запросы для других URL будут обрабатываться по умолчанию фильтром безопасности модуля Jmix UI.
<3> Инструкция `permitAll()` предоставляет доступ к эндпойнтам.
<4> Отключает CSRF для запросов POST.
<5> Вызов `JmixHttpSecurityUtils.configureAnonymous(http)` настраивает анонимную аутентификацию, установив анонимного пользователя, возвращенного Jmix `UserRepository`, в контекст безопасности.

[[http-basic-authentication-example]]
==== Аутентификация HTTP Basic

Данный пример демонстрирует, как защищать эндпойнты контроллера с помощью HTTP Basic аутентификации.

Класс контроллера:

[source,java,indent=0]
----
include::example$/security-ex1/src/main/java/com/company/demo/controller/BasicGreetingController.java[tags=whole-class]
----

Запросы с URL, соответствующими шаблону `pass:[/api/**]`, должны быть защищены HTTP Basic аутентификацией, а запросы к `pass:[/api/public/**]` должны быть доступны для любого пользователя. Этого можно достичь с помощью конфигурации ниже:

[source,java,indent=0]
----
include::example$/security-ex1/src/main/java/com/company/demo/security/api/BasicControllerSecurityConfiguration.java[tags=whole-class]
----

<1> `JmixSecurityFilterChainOrder.CUSTOM` — порядок меньше любого другого порядка безопасности фильтра Jmix.
<2> Матчер безопасности указывает, что `HttpSecurity` будет применяться только для запросов `pass:[/api/**]`.
<3> Если запрос соответствует матчеру безопасности, то мы можем предоставить дополнительные правила. Все запросы для `pass:[/api/public/**]` должны быть разрешены без аутентификации.
<4> Все запросы, которые не соответствуют шаблону `pass:[/api/public/**]`, должны быть аутентифицированы.
<5> Включает HTTP Basic аутентификацию.
<6> Использует `AuthenticationManager`, настроенный Jmix для HTTP Basic аутентификации.

Запросы к эндпойнтам `pass:[/api/**]` должны содержать заголовок в формате `Authorization: Basic <credentials>`, где `<credentials>` — Base64-кодированная строка, состоящая из имени пользователя и пароля, разделенных одиночным знаком двоеточия. Например:

[source]
----
GET /api/hello HTTP/1.1
Host: server.example.com
Authorization: Basic YWRtaW46YWRtaW4=
----

TIP: В этом примере доступ к `pass:[/api/public/**]` можно альтернативно настроить с помощью другого бина `SecurityFilterChain`, который имеет матчер безопасности `pass:[/api/public/**]` и порядок меньше текущего, например, `JmixSecurityFilterChainOrder.CUSTOM - 10`.

[[token-based-authentication]]
== Аутентификация с помощью токенов

You can protect custom endpoints using bearer tokens issued by the xref:authorization-server:index.adoc[Authorization Server] or an external identity provider, such as Keycloak, when using the xref:oidc:index.adoc[OpenID Connect] add-on. The security configurations of the Authorization Server and the OpenID Connect add-ons provide extension points for this purpose. In the context of the OAuth 2.1 specification, your application that hosts the protected endpoints acts as a *resource server*.

Suppose you have a REST controller:

[source,java,indent=0]
----
include::example$/security-ex1/src/main/java/com/company/demo/controller/GreetingController.java[tags=whole-class]
----

There are several ways to determine which endpoints should be protected with token-based authentication and which can be accessed anonymously.

[[application-properties]]
=== Application Properties

The simplest way to determine which endpoints of a resource server should be protected and which should have public access, is by using the following application properties:

[source,properties,indent=0]
----
include::example$/security-ex1/src/main/resources/application.properties[tags=resource-server-endpoints-security]
----

[[url-patterns-providers]]
=== URL Patterns Providers

Another way to define which endpoints need to be protected with token-based authentication is to implement the `AuthenticatedUrlPatternsProvider` interface and return a list of URL patterns from its `getAuthenticatedUrlPatterns()` method. This approach is more flexible and allows you to define more complex rules for endpoint protection.

[source,java,indent=0]
----
include::example$/security-ex1/src/main/java/com/company/demo/security/resserver/GreetingAuthenticatedUrlPatternsProvider.java[tags=whole-class]
----

Resource server endpoints that must be accessed anonymously can be defined in the same way using the `AnonymousUrlPatternsProvider` interface.

[source,java,indent=0]
----
include::example$/security-ex1/src/main/java/com/company/demo/security/resserver/GreetingAnonymousUrlPatternsProvider.java[tags=whole-class]
----

[[request-matcher-provider]]
=== RequestMatcher Provider

Application properties and URL patterns providers allow you to define endpoints protection rules that operate a collection of strings with URL patterns. If you need to provide more complex rules, such as not only the URL pattern but also the HTTP method, you can implement the `AuthenticatedRequestMatcherProvider` interface and return a `RequestMatcher` object from its `getAuthenticatedRequestMatcher()` method.

[source,java,indent=0]
----
include::example$/security-ex1/src/main/java/com/company/demo/security/resserver/GreetingAuthenticatedRequestMatcherProvider.java[tags=whole-class]
----

RequestMatcher for public endpoints of the resource server can be defined in the same way using the `AnonymousRequestMatcherProvider` interface.

[source,java,indent=0]
----
include::example$/security-ex1/src/main/java/com/company/demo/security/resserver/GreetingAnonymousRequestMatcherProvider.java[tags=whole-class]
----

[[accessing-resource-server-endpoints]]
=== Accessing Resource Server Endpoints

After any of the above configurations are defined, all requests to protected `pass:[/greeting/**]` endpoints of the resource server will require a bearer access token in the `Authorization` header. For example:

[source]
----
GET /greeting/hello HTTP/1.1
Host: server.example.com
Authorization: Bearer <ACCESS_TOKEN>
----

[[troubleshooting]]
== Устранение проблем

Если вы столкнулись с HTTP-ошибкой 401 Unauthorized или 403 Forbidden или с какими-либо другими проблемами, связанными с безопасностью эндпойнтов, то включите {spring-security-doc}/servlet/architecture.html#servlet-logging[логгирование^] Spring Security. Для этого добавьте следующее свойство с значением DEBUG или TRACE в файл `application.properties`:

[source,properties]
----
logging.level.org.springframework.security = TRACE
----

